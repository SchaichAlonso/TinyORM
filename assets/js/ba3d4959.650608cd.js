"use strict";(self.webpackChunktinyorm_org=self.webpackChunktinyorm_org||[]).push([[784],{3905:(e,t,n)=>{n.d(t,{Zo:()=>d,kt:()=>c});var a=n(7294);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,a,i=function(e,t){if(null==e)return{};var n,a,i={},r=Object.keys(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var l=a.createContext({}),p=function(e){var t=a.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},d=function(e){var t=p(e.components);return a.createElement(l.Provider,{value:t},e.children)},u={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},m=a.forwardRef((function(e,t){var n=e.components,i=e.mdxType,r=e.originalType,l=e.parentName,d=s(e,["components","mdxType","originalType","parentName"]),m=p(n),c=i,h=m["".concat(l,".").concat(c)]||m[c]||u[c]||r;return n?a.createElement(h,o(o({ref:t},d),{},{components:n})):a.createElement(h,o({ref:t},d))}));function c(e,t){var n=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var r=n.length,o=new Array(r);o[0]=m;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s.mdxType="string"==typeof e?e:i,o[1]=s;for(var p=2;p<r;p++)o[p]=n[p];return a.createElement.apply(null,o)}return a.createElement.apply(null,n)}m.displayName="MDXCreateElement"},1935:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>o,default:()=>u,frontMatter:()=>r,metadata:()=>s,toc:()=>p});var a=n(7462),i=(n(7294),n(3905));const r={sidebar_position:0,sidebar_label:"Getting Started",description:"TinyORM makes interacting with a database extremely simple using raw SQL, a fluent query builder, and the TinyORM. It provides first-party support for three databases MySQL/MariaDB, PostgreSQL, and SQLite.",keywords:["c++ orm","database","getting started","tinyorm"]},o="Database: Getting Started",s={unversionedId:"database/getting-started",id:"database/getting-started",title:"Database: Getting Started",description:"TinyORM makes interacting with a database extremely simple using raw SQL, a fluent query builder, and the TinyORM. It provides first-party support for three databases MySQL/MariaDB, PostgreSQL, and SQLite.",source:"@site/docs/database/getting-started.mdx",sourceDirName:"database",slug:"/database/getting-started",permalink:"/database/getting-started",draft:!1,editUrl:"https://github.com/silverqx/TinyORM-github.io/edit/main/docs/database/getting-started.mdx",tags:[],version:"current",sidebarPosition:0,frontMatter:{sidebar_position:0,sidebar_label:"Getting Started",description:"TinyORM makes interacting with a database extremely simple using raw SQL, a fluent query builder, and the TinyORM. It provides first-party support for three databases MySQL/MariaDB, PostgreSQL, and SQLite.",keywords:["c++ orm","database","getting started","tinyorm"]},sidebar:"tinyormSidebar",previous:{title:"\ud83d\ude80 Supported Compilers",permalink:"/supported-compilers"},next:{title:"Query Builder",permalink:"/database/query-builder"}},l={},p=[{value:"Introduction",id:"introduction",level:2},{value:"Configuration",id:"configuration",level:3},{value:"SQLite Configuration",id:"sqlite-configuration",level:4},{value:"Running SQL Queries",id:"running-sql-queries",level:2},{value:"Running A Select Query",id:"running-a-select-query",level:4},{value:"Running An Insert Statement",id:"running-an-insert-statement",level:4},{value:"Running An Update Statement",id:"running-an-update-statement",level:4},{value:"Running A Delete Statement",id:"running-a-delete-statement",level:4},{value:"Running A General Statement",id:"running-a-general-statement",level:4},{value:"Running An Unprepared Statement",id:"running-an-unprepared-statement",level:4},{value:"Implicit Commits",id:"implicit-commits",level:4},{value:"Using Multiple Database Connections",id:"using-multiple-database-connections",level:3},{value:"Database Transactions",id:"database-transactions",level:2},{value:"Manually Using Transactions",id:"manually-using-transactions",level:4},{value:"Multi-threading support",id:"multi-threading-support",level:2}],d={toc:p};function u(e){let{components:t,...n}=e;return(0,i.kt)("wrapper",(0,a.Z)({},d,n,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"database-getting-started"},"Database: Getting Started"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#introduction"},"Introduction"),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#configuration"},"Configuration")))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#running-sql-queries"},"Running SQL Queries"),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#using-multiple-database-connections"},"Using Multiple Database Connections")))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#database-transactions"},"Database Transactions")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#multi-threading-support"},"Multi-threading support"))),(0,i.kt)("h2",{id:"introduction"},"Introduction"),(0,i.kt)("p",null,"Almost every modern application interacts with a database. TinyORM makes interacting with a database extremely simple using raw SQL, a ",(0,i.kt)("a",{parentName:"p",href:"/database/query-builder"},"fluent query builder"),", and the ",(0,i.kt)("a",{parentName:"p",href:"/tinyorm/getting-started"},"TinyORM"),". Currently, TinyORM provides first-party support for three databases:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"MySQL 5.7+ (",(0,i.kt)("a",{parentName:"li",href:"https://en.wikipedia.org/wiki/MySQL#Release_history"},"Version Policy"),")"),(0,i.kt)("li",{parentName:"ul"},"MariaDB 10.3+ (",(0,i.kt)("a",{parentName:"li",href:"https://mariadb.org/about/#maintenance-policy"},"Version Policy"),")"),(0,i.kt)("li",{parentName:"ul"},"PostgreSQL 11+ (",(0,i.kt)("a",{parentName:"li",href:"https://www.postgresql.org/support/versioning/"},"Version Policy"),")"),(0,i.kt)("li",{parentName:"ul"},"SQLite 3.8.8+")),(0,i.kt)("p",null,"TinyORM internally uses ",(0,i.kt)("inlineCode",{parentName:"p"},"QtSql")," module, you can look for ",(0,i.kt)("a",{parentName:"p",href:"https://doc.qt.io/qt-5/sql-driver.html#supported-databases"},"supported databases"),"."),(0,i.kt)("admonition",{type:"note"},(0,i.kt)("p",{parentName:"admonition"},"TinyORM's code is ready and designed to simply add support for the  SQL Server.")),(0,i.kt)("h3",{id:"configuration"},"Configuration"),(0,i.kt)("p",null,"You can create and configure new database connection by ",(0,i.kt)("inlineCode",{parentName:"p"},"create")," method provided by ",(0,i.kt)("inlineCode",{parentName:"p"},"DB")," facade:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},'#include <orm/db.hpp>\n\nusing Orm::DB;\n\n// Ownership of a shared_ptr()\nauto manager = DB::create({\n    {"driver",    "QMYSQL"},\n    {"host",      qEnvironmentVariable("DB_HOST", "127.0.0.1")},\n    {"port",      qEnvironmentVariable("DB_PORT", "3306")},\n    {"database",  qEnvironmentVariable("DB_DATABASE", "")},\n    {"username",  qEnvironmentVariable("DB_USERNAME", "root")},\n    {"password",  qEnvironmentVariable("DB_PASSWORD", "")},\n    {"charset",   qEnvironmentVariable("DB_CHARSET", "utf8mb4")},\n    {"collation", qEnvironmentVariable("DB_COLLATION", "utf8mb4_0900_ai_ci")},\n    {"timezone",  "+00:00"},\n    {"strict",    true},\n    {"options",   QVariantHash()},\n});\n')),(0,i.kt)("p",null,"The first argument is configuration hash which is of type ",(0,i.kt)("inlineCode",{parentName:"p"},"QVariantHash")," and the second argument specifies the name of the ",(0,i.kt)("em",{parentName:"p"},"connection"),", this connection will also be a ",(0,i.kt)("em",{parentName:"p"},"default connection"),". You can configure multiple database connections at once and choose the needed one before executing SQL query, section ",(0,i.kt)("a",{parentName:"p",href:"#using-multiple-database-connections"},"Using Multiple Database Connections")," describes how to create and use multiple database connections."),(0,i.kt)("p",null,"You may also configure connection options by ",(0,i.kt)("inlineCode",{parentName:"p"},"options")," key as ",(0,i.kt)("inlineCode",{parentName:"p"},"QVariantHash")," or ",(0,i.kt)("inlineCode",{parentName:"p"},"QString"),", you can pass any ",(0,i.kt)("a",{parentName:"p",href:"https://doc.qt.io/qt-5/qsqldatabase.html#setConnectOptions"},"connection options")," supported by ",(0,i.kt)("inlineCode",{parentName:"p"},"QSqlDatabase"),"."),(0,i.kt)("p",null,"You can also configure ",(0,i.kt)("a",{parentName:"p",href:"https://dev.mysql.com/doc/refman/8.0/en/innodb-transaction-isolation-levels.html"},"Transaction Isolation Levels")," for MySQL connection with the ",(0,i.kt)("inlineCode",{parentName:"p"},"isolation_level")," configuration option."),(0,i.kt)("admonition",{type:"info"},(0,i.kt)("p",{parentName:"admonition"},"A database connection is resolved lazily, which means that the connection configuration is only saved after the ",(0,i.kt)("inlineCode",{parentName:"p"},"DB::create")," method call. The connection will be resolved after you run some query or you can create it using the ",(0,i.kt)("inlineCode",{parentName:"p"},"DB::connection")," method.")),(0,i.kt)("admonition",{type:"tip"},(0,i.kt)("p",{parentName:"admonition"},"You can also use predefined string constants to avoid unnecessary ",(0,i.kt)("inlineCode",{parentName:"p"},"QString")," instantiations, as used in the ",(0,i.kt)("inlineCode",{parentName:"p"},"tom")," migrations ",(0,i.kt)("a",{parentName:"p",href:"/building/migrations#string-constants-example"},"example"),".")),(0,i.kt)("h4",{id:"sqlite-configuration"},"SQLite Configuration"),(0,i.kt)("p",null,"SQLite databases are contained within a single file on your filesystem. You can create a new SQLite database using the ",(0,i.kt)("inlineCode",{parentName:"p"},"touch")," command in your terminal: ",(0,i.kt)("inlineCode",{parentName:"p"},"touch database.sqlite3"),". After the database has been created, you may configure SQLite database connection:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},'#include <orm/db.hpp>\n\n// Ownership of a shared_ptr()\nauto manager = DB::create({\n    {"driver",    "QSQLITE"},\n    {"database",  qEnvironmentVariable("DB_DATABASE", "/absolute/path/to/database.sqlite3")},\n    {"foreign_key_constraints", qEnvironmentVariable("DB_FOREIGN_KEYS", "true")},\n    {"check_database_exists",   true},\n});\n')),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"database")," configuration value is the absolute path to the database. To enable foreign key constraints for SQLite connections, you should set the ",(0,i.kt)("inlineCode",{parentName:"p"},"foreign_key_constraints")," configuration value to ",(0,i.kt)("inlineCode",{parentName:"p"},"true"),", if this configuration value is not set, then the default of the SQLite driver will be used."),(0,i.kt)("p",null,"If the ",(0,i.kt)("inlineCode",{parentName:"p"},"check_database_exists")," configuration value is set to the ",(0,i.kt)("inlineCode",{parentName:"p"},"true")," value, then the database connection throws an ",(0,i.kt)("inlineCode",{parentName:"p"},"Orm::InvalidArgumentError")," exception, when the SQLite database file doesn't exist. If it is set to the ",(0,i.kt)("inlineCode",{parentName:"p"},"false")," value and the SQLite database file doesn't exist, then it will be created for you by SQLite driver. The default value is ",(0,i.kt)("inlineCode",{parentName:"p"},"true"),"."),(0,i.kt)("h2",{id:"running-sql-queries"},"Running SQL Queries"),(0,i.kt)("p",null,"Once you have configured your database connection, you may run queries using the ",(0,i.kt)("inlineCode",{parentName:"p"},"DB")," facade. The ",(0,i.kt)("inlineCode",{parentName:"p"},"DB")," facade provides methods for each type of query: ",(0,i.kt)("inlineCode",{parentName:"p"},"select"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"update"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"insert"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"delete"),", and ",(0,i.kt)("inlineCode",{parentName:"p"},"statement"),"."),(0,i.kt)("h4",{id:"running-a-select-query"},"Running A Select Query"),(0,i.kt)("p",null,"To run a basic SELECT query, you may use the ",(0,i.kt)("inlineCode",{parentName:"p"},"select")," method on the ",(0,i.kt)("inlineCode",{parentName:"p"},"DB")," facade:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},'auto users = DB::select("select * from users where active = ?", {1});\n')),(0,i.kt)("p",null,"The first argument passed to the ",(0,i.kt)("inlineCode",{parentName:"p"},"select")," method is the SQL query, while the second argument is any parameter bindings that need to be bound to the query. Typically, these are the values of the ",(0,i.kt)("inlineCode",{parentName:"p"},"where")," clause constraints. Parameter binding provides protection against SQL injection."),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"select")," method returns a ",(0,i.kt)("inlineCode",{parentName:"p"},"QSqlQuery")," containing the results of the query, where each result can be accessed by ",(0,i.kt)("inlineCode",{parentName:"p"},"QSqlQuery::next")," method. Look into the ",(0,i.kt)("inlineCode",{parentName:"p"},"QSqlQuery"),' documentation on how to obtain results from the "query". You may access each column\'s value by ',(0,i.kt)("inlineCode",{parentName:"p"},"QSqlQuery::value")," method. The first ",(0,i.kt)("inlineCode",{parentName:"p"},"bool")," return value is the value returned from ",(0,i.kt)("inlineCode",{parentName:"p"},"QSqlQuery::exec")," method:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},'#include <QDebug>\n\n#include <orm/db.hpp>\n\nauto users = DB::select("select * from users");\n\nwhile(users.next())\n    qDebug() << users.value("name").toString();\n')),(0,i.kt)("h4",{id:"running-an-insert-statement"},"Running An Insert Statement"),(0,i.kt)("p",null,"To execute an ",(0,i.kt)("inlineCode",{parentName:"p"},"insert")," statement, you may use the ",(0,i.kt)("inlineCode",{parentName:"p"},"insert")," method on the ",(0,i.kt)("inlineCode",{parentName:"p"},"DB")," facade. Like ",(0,i.kt)("inlineCode",{parentName:"p"},"select"),", this method accepts the SQL query as its first argument and bindings as its second argument and returns ",(0,i.kt)("inlineCode",{parentName:"p"},"QSqlQuery"),":"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},'#include <orm/db.hpp>\n\nDB::insert("insert into users (id, name) values (?, ?)", {1, "Marc"});\n')),(0,i.kt)("h4",{id:"running-an-update-statement"},"Running An Update Statement"),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"update")," method should be used to update existing records in the database. The number of rows affected by the statement and ",(0,i.kt)("inlineCode",{parentName:"p"},"QSqlQuery")," is returned by the method as ",(0,i.kt)("inlineCode",{parentName:"p"},"std::tuple<int, QSqlQuery>"),":"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},'#include <QDateTime>\n\n#include <orm/db.hpp>\n\nauto [affected, query] = DB::update(\n    "update users set updated_at = ? where name = ?",\n    {QDateTime::currentDateTime(), "Anita"}\n);\n\nif (!affected)\n    qDebug() << "Any record was updated.";\n')),(0,i.kt)("h4",{id:"running-a-delete-statement"},"Running A Delete Statement"),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"remove")," method should be used to delete records from the database. Like ",(0,i.kt)("inlineCode",{parentName:"p"},"update"),", the number of affected rows and ",(0,i.kt)("inlineCode",{parentName:"p"},"QSqlQuery")," will be returned by the method as ",(0,i.kt)("inlineCode",{parentName:"p"},"std::tuple<int, QSqlQuery>"),":"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},'#include <orm/db.hpp>\n\nauto [affected, query] = DB::remove("delete from users");\n')),(0,i.kt)("admonition",{type:"note"},(0,i.kt)("p",{parentName:"admonition"},(0,i.kt)("inlineCode",{parentName:"p"},"delete")," can not be used as the method name because it is the reserved word.")),(0,i.kt)("h4",{id:"running-a-general-statement"},"Running A General Statement"),(0,i.kt)("p",null,"Some database statements do not return any value. For these types of operations, you may use the ",(0,i.kt)("inlineCode",{parentName:"p"},"statement")," method on the ",(0,i.kt)("inlineCode",{parentName:"p"},"DB")," facade:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},'DB::statement("drop table users");\n')),(0,i.kt)("admonition",{type:"tip"},(0,i.kt)("p",{parentName:"admonition"},(0,i.kt)("inlineCode",{parentName:"p"},"DB::statement")," method should be used for ",(0,i.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Data_definition_language"},"DDL"),' queries, don\'t use it for "select" queries because it internally calls ',(0,i.kt)("inlineCode",{parentName:"p"},"recordsHaveBeenModified")," method.")),(0,i.kt)("h4",{id:"running-an-unprepared-statement"},"Running An Unprepared Statement"),(0,i.kt)("p",null,"Sometimes you may want to execute an SQL statement without binding any values. You may use the ",(0,i.kt)("inlineCode",{parentName:"p"},"DB")," facade's ",(0,i.kt)("inlineCode",{parentName:"p"},"unprepared")," method to accomplish this:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"DB::unprepared(\"update users set votes = 100 where name = 'Dries'\");\n")),(0,i.kt)("admonition",{type:"caution"},(0,i.kt)("p",{parentName:"admonition"},"Since unprepared statements do not bind parameters, they may be vulnerable to SQL injection. You should never allow user controlled values within an unprepared statement.")),(0,i.kt)("h4",{id:"implicit-commits"},"Implicit Commits"),(0,i.kt)("p",null,"When using the ",(0,i.kt)("inlineCode",{parentName:"p"},"DB")," facade's ",(0,i.kt)("inlineCode",{parentName:"p"},"statement")," methods within transactions, you must be careful to avoid statements that cause ",(0,i.kt)("a",{parentName:"p",href:"https://dev.mysql.com/doc/refman/8.0/en/implicit-commit.html"},"implicit commits"),". These statements will cause the database engine to indirectly commit the entire transaction, leaving TinyORM unaware of the database's transaction level. An example of such a statement is creating a database table:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},'DB::statement("create table users (name varchar(255) null)");\n')),(0,i.kt)("p",null,"Please refer to the MySQL manual for ",(0,i.kt)("a",{parentName:"p",href:"https://dev.mysql.com/doc/refman/8.0/en/implicit-commit.html"},"a list of all statements")," that trigger implicit commits."),(0,i.kt)("h3",{id:"using-multiple-database-connections"},"Using Multiple Database Connections"),(0,i.kt)("p",null,"You can configure multiple database connections at once during ",(0,i.kt)("inlineCode",{parentName:"p"},"DatabaseManager")," instantiation using the ",(0,i.kt)("inlineCode",{parentName:"p"},"DB::create")," overload, where the first argument is a hash of multiple connections and is of type ",(0,i.kt)("inlineCode",{parentName:"p"},"QHash<QString, QVariantHash>")," and the second argument is the name of the default connection:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},'#include <orm/db.hpp>\n\n// Ownership of a shared_ptr()\nauto manager = DB::create({\n    {"mysql", {\n        {"driver",    "QMYSQL"},\n        {"host",      qEnvironmentVariable("DB_MYSQL_HOST", "127.0.0.1")},\n        {"port",      qEnvironmentVariable("DB_MYSQL_PORT", "3306")},\n        {"database",  qEnvironmentVariable("DB_MYSQL_DATABASE", "")},\n        {"username",  qEnvironmentVariable("DB_MYSQL_USERNAME", "root")},\n        {"password",  qEnvironmentVariable("DB_MYSQL_PASSWORD", "")},\n        {"charset",   qEnvironmentVariable("DB_MYSQL_CHARSET", "utf8mb4")},\n        {"collation", qEnvironmentVariable("DB_MYSQL_COLLATION", "utf8mb4_0900_ai_ci")},\n        {"strict",    true},\n        {"options",   QVariantHash()},\n    }},\n    {"sqlite", {\n        {"driver",    "QSQLITE"},\n        {"database",  qEnvironmentVariable("DB_SQLITE_DATABASE", "")},\n        {"foreign_key_constraints", qEnvironmentVariable("DB_SQLITE_FOREIGN_KEYS", "true")},\n        {"check_database_exists",   true},\n    }},\n}, "mysql");\n')),(0,i.kt)("p",null,"If your application needs to use multiple connections, you may access each connection via the ",(0,i.kt)("inlineCode",{parentName:"p"},"connection")," method provided by the ",(0,i.kt)("inlineCode",{parentName:"p"},"DB")," facade. The connection name passed to the ",(0,i.kt)("inlineCode",{parentName:"p"},"connection")," method should correspond to one of the connections key listed in your configuration:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},'#include <orm/db.hpp>\n\nauto query = DB::connection("mysql_test").select(...);\n')),(0,i.kt)("p",null,"You may access the raw underlying ",(0,i.kt)("inlineCode",{parentName:"p"},"QSqlQuery")," instance of a connection using the ",(0,i.kt)("inlineCode",{parentName:"p"},"getQtQuery")," method on a connection instance:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"auto query = DB::connection().getQtQuery();\n")),(0,i.kt)("p",null,"Or you can use the shortcut method ",(0,i.kt)("inlineCode",{parentName:"p"},"qtQuery")," provided by the ",(0,i.kt)("inlineCode",{parentName:"p"},"DB")," facade:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"auto query = DB::qtQuery();\n")),(0,i.kt)("h2",{id:"database-transactions"},"Database Transactions"),(0,i.kt)("h4",{id:"manually-using-transactions"},"Manually Using Transactions"),(0,i.kt)("p",null,"If you would like to begin a transaction manually and have complete control over rollbacks and commits, you may use the ",(0,i.kt)("inlineCode",{parentName:"p"},"beginTransaction")," method provided by the ",(0,i.kt)("inlineCode",{parentName:"p"},"DB")," facade:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"#include <orm/db.hpp>\n\nDB::beginTransaction();\n")),(0,i.kt)("p",null,"You can rollback the transaction via the ",(0,i.kt)("inlineCode",{parentName:"p"},"rollBack")," method:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"DB::rollBack();\n")),(0,i.kt)("p",null,"Lastly, you can commit a transaction via the ",(0,i.kt)("inlineCode",{parentName:"p"},"commit")," method:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"DB::commit();\n")),(0,i.kt)("p",null,"All transaction methods accept a connection name as the optional argument:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},'DB::beginTransaction("mysql_test");\n')),(0,i.kt)("admonition",{type:"tip"},(0,i.kt)("p",{parentName:"admonition"},"The ",(0,i.kt)("inlineCode",{parentName:"p"},"DB")," facade's transaction methods control the transactions for both the ",(0,i.kt)("a",{parentName:"p",href:"/database/query-builder"},"query builder")," and ",(0,i.kt)("a",{parentName:"p",href:"/tinyorm/getting-started"},"TinyORM"),".")),(0,i.kt)("h2",{id:"multi-threading-support"},"Multi-threading support"),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"TinyORM")," supports multi-threading for the ",(0,i.kt)("inlineCode",{parentName:"p"},"MSVC")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"GCC")," on Linux compilers. Multi-threading is disabled for the ",(0,i.kt)("inlineCode",{parentName:"p"},"Clang <14.0.3")," compiler on MSYS2, ",(0,i.kt)("inlineCode",{parentName:"p"},"Clang <14.0.4")," on Linux and for the ",(0,i.kt)("inlineCode",{parentName:"p"},"GCC")," compiler on MSYS2. The reason are bugs in the ",(0,i.kt)("inlineCode",{parentName:"p"},"TLS")," wrapper that is generated by the ",(0,i.kt)("a",{parentName:"p",href:"https://en.cppreference.com/w/cpp/keyword/thread_local"},(0,i.kt)("inlineCode",{parentName:"a"},"thread_local"))," keyword."),(0,i.kt)("p",null,"A connection can only be used from within the thread that created it. Moving connections between threads or creating queries from a different thread where the connection was created is not supported."),(0,i.kt)("p",null,"In addition, the third party libraries used by the ",(0,i.kt)("inlineCode",{parentName:"p"},"QSqlDrivers")," can impose further restrictions on using the SQL Module in a multithreaded program."),(0,i.kt)("p",null,"In short, if you create a ",(0,i.kt)("inlineCode",{parentName:"p"},"DB::connection")," in some thread then you have to use this connection only from this particular thread and of course all queries that will be executed on this connection."),(0,i.kt)("p",null,"If you want to execute some query from another thread for the same connection then you have to create a new connection first and if you have a new connection you can send a query from this new thread to the database."),(0,i.kt)("admonition",{type:"caution"},(0,i.kt)("p",{parentName:"admonition"},"The ",(0,i.kt)("a",{parentName:"p",href:"/database/migrations#tables"},(0,i.kt)("inlineCode",{parentName:"a"},"schema builder"))," and ",(0,i.kt)("a",{parentName:"p",href:"/database/migrations"},(0,i.kt)("inlineCode",{parentName:"a"},"migrations"))," don't support multi-threading.")))}u.isMDXComponent=!0}}]);