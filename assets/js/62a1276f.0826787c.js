"use strict";(self.webpackChunktinyorm_org=self.webpackChunktinyorm_org||[]).push([[57],{3905:(e,t,a)=>{a.d(t,{Zo:()=>m,kt:()=>c});var n=a(7294);function i(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function r(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}function o(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?r(Object(a),!0).forEach((function(t){i(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):r(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function s(e,t){if(null==e)return{};var a,n,i=function(e,t){if(null==e)return{};var a,n,i={},r=Object.keys(e);for(n=0;n<r.length;n++)a=r[n],t.indexOf(a)>=0||(i[a]=e[a]);return i}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(n=0;n<r.length;n++)a=r[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(i[a]=e[a])}return i}var l=n.createContext({}),p=function(e){var t=n.useContext(l),a=t;return e&&(a="function"==typeof e?e(t):o(o({},t),e)),a},m=function(e){var t=p(e.components);return n.createElement(l.Provider,{value:t},e.children)},d={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},u=n.forwardRef((function(e,t){var a=e.components,i=e.mdxType,r=e.originalType,l=e.parentName,m=s(e,["components","mdxType","originalType","parentName"]),u=p(a),c=i,y=u["".concat(l,".").concat(c)]||u[c]||d[c]||r;return a?n.createElement(y,o(o({ref:t},m),{},{components:a})):n.createElement(y,o({ref:t},m))}));function c(e,t){var a=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var r=a.length,o=new Array(r);o[0]=u;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s.mdxType="string"==typeof e?e:i,o[1]=s;for(var p=2;p<r;p++)o[p]=a[p];return n.createElement.apply(null,o)}return n.createElement.apply(null,a)}u.displayName="MDXCreateElement"},9823:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>l,contentTitle:()=>o,default:()=>d,frontMatter:()=>r,metadata:()=>s,toc:()=>p});var n=a(7462),i=(a(7294),a(3905));const r={sidebar_position:2,sidebar_label:"Casts",description:"Attribute casting allow you to transform TinyORM attribute values when you retrieve them on model instances. For example, you may want to convert a `datetime` string that is stored in your database to the `QDateTime` instance when it is accessed via your TinyORM model.",keywords:["c++ orm","orm","casts","casting","attributes","tinyorm"]},o="TinyORM: Casting",s={unversionedId:"tinyorm/casts",id:"tinyorm/casts",title:"TinyORM: Casting",description:"Attribute casting allow you to transform TinyORM attribute values when you retrieve them on model instances. For example, you may want to convert a `datetime` string that is stored in your database to the `QDateTime` instance when it is accessed via your TinyORM model.",source:"@site/docs/tinyorm/casts.mdx",sourceDirName:"tinyorm",slug:"/tinyorm/casts",permalink:"/tinyorm/casts",draft:!1,editUrl:"https://github.com/silverqx/TinyORM-github.io/edit/main/docs/tinyorm/casts.mdx",tags:[],version:"current",sidebarPosition:2,frontMatter:{sidebar_position:2,sidebar_label:"Casts",description:"Attribute casting allow you to transform TinyORM attribute values when you retrieve them on model instances. For example, you may want to convert a `datetime` string that is stored in your database to the `QDateTime` instance when it is accessed via your TinyORM model.",keywords:["c++ orm","orm","casts","casting","attributes","tinyorm"]},sidebar:"tinyormSidebar",previous:{title:"Relationships",permalink:"/tinyorm/relationships"},next:{title:"TinyORM",permalink:"/building/tinyorm"}},l={},p=[{value:"Introduction",id:"introduction",level:2},{value:"Attribute Casting",id:"attribute-casting",level:2},{value:"Date Casting",id:"date-casting",level:3},{value:"Query Time Casting",id:"query-time-casting",level:3}],m={toc:p};function d(e){let{components:t,...a}=e;return(0,i.kt)("wrapper",(0,n.Z)({},m,a,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"tinyorm-casting"},"TinyORM: Casting"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#introduction"},"Introduction")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#attribute-casting"},"Attribute Casting"),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#date-casting"},"Date Casting")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#query-time-casting"},"Query Time Casting"))))),(0,i.kt)("h2",{id:"introduction"},"Introduction"),(0,i.kt)("p",null,"Attribute casting allows you to transform TinyORM attribute values when you retrieve them on model instances. For example, you may want to convert a ",(0,i.kt)("inlineCode",{parentName:"p"},"datetime")," string that is stored in your database to the ",(0,i.kt)("inlineCode",{parentName:"p"},"QDateTime")," instance when it is accessed via your TinyORM model. Or, you may want to convert a ",(0,i.kt)("inlineCode",{parentName:"p"},"tinyint")," number that is stored in the database to the ",(0,i.kt)("inlineCode",{parentName:"p"},"bool")," when you access it on the TinyORM model."),(0,i.kt)("h2",{id:"attribute-casting"},"Attribute Casting"),(0,i.kt)("p",null,"Attribute casting provides functionality that allows converting model attributes to the appropriate ",(0,i.kt)("inlineCode",{parentName:"p"},"QVariant")," ",(0,i.kt)("strong",{parentName:"p"},"metatype")," when it is accessed via your TinyORM model. The core of this functionality is a model's ",(0,i.kt)("inlineCode",{parentName:"p"},"u_casts")," data member that provides a convenient method of converting attributes' ",(0,i.kt)("inlineCode",{parentName:"p"},"QVariant")," ",(0,i.kt)("strong",{parentName:"p"},"internal types")," to the defined cast types."),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"u_casts")," data member should be the ",(0,i.kt)("inlineCode",{parentName:"p"},"std::unordered_map<QString, Orm::CastItem>")," where the key is the name of the attribute being cast and the value is the type you wish to cast the column to. The supported cast types are:"),(0,i.kt)("div",{id:"casts-types-list"},(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"CastType::QString")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"CastType::Boolean")," / ",(0,i.kt)("inlineCode",{parentName:"li"},"CastType::Bool")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"CastType::Integer")," / ",(0,i.kt)("inlineCode",{parentName:"li"},"CastType::Int")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"CastType::UInteger")," / ",(0,i.kt)("inlineCode",{parentName:"li"},"CastType::UInt")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"CastType::LongLong")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"CastType::ULongLong")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"CastType::Short")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"CastType::UShort")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"CastType::QDate")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"CastType::QDateTime")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"CastType::Timestamp")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"CastType::Real")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"CastType::Float")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"CastType::Double")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("code",null,"CastType::Decimal:<precision>")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"CastType::QByteArray")))),(0,i.kt)("p",null,"To demonstrate attribute casting, let's cast the ",(0,i.kt)("inlineCode",{parentName:"p"},"is_admin")," attribute, which is stored in our database as an integer (",(0,i.kt)("inlineCode",{parentName:"p"},"0")," or ",(0,i.kt)("inlineCode",{parentName:"p"},"1"),") to a ",(0,i.kt)("inlineCode",{parentName:"p"},"QVariant(bool)")," value:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},'#pragma once\n\n#include <orm/tiny/model.hpp>\n\nusing Orm::Tiny::CastItem;\nusing Orm::Tiny::CastType;\nusing Orm::Tiny::Model;\n\nclass User final : public Model<User>\n{\n    friend Model;\n    using Model::Model;\n\n    /*! The attributes that should be cast. */\n    std::unordered_map<QString, CastItem> u_casts {\n        {"is_admin", CastType::Boolean},\n    };\n};\n')),(0,i.kt)("p",null,"After defining the cast, the ",(0,i.kt)("inlineCode",{parentName:"p"},"is_admin")," attribute will always be cast to a ",(0,i.kt)("inlineCode",{parentName:"p"},"QVariant(bool)")," when you access it, even if the underlying value is stored in the database as an integer:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},'using Orm::Utils::Helpers;\n\nauto isAdmin = User::find(1)->getAttribute("is_admin");\n\n// Proof of the QVariant type\nQ_ASSERT(Helpers::qVariantTypeId(isAdmin) == QMetaType::Bool);\n\nif (isAdmin.value<bool>()) {\n    //\n}\n')),(0,i.kt)("p",null,"If you need to add a new, ",(0,i.kt)("strong",{parentName:"p"},"temporary")," cast at runtime, you may use the ",(0,i.kt)("inlineCode",{parentName:"p"},"mergeCasts")," method. These cast definitions will be added to any of the casts already defined on the model:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},'user->mergeCasts({\n    {"is_paid", CastType::Boolean},\n    {"income", {CastType::Decimal, 2}},\n});\n')),(0,i.kt)("admonition",{type:"caution"},(0,i.kt)("p",{parentName:"admonition"},"You should never define a cast (or an attribute) that has the same name as a relationship.")),(0,i.kt)("admonition",{type:"info"},(0,i.kt)("p",{parentName:"admonition"},"Attributes that are ",(0,i.kt)("inlineCode",{parentName:"p"},"null")," ",(0,i.kt)("strong",{parentName:"p"},"will also be")," cast so that the ",(0,i.kt)("inlineCode",{parentName:"p"},"QVariant"),"'s internal type will have the correct type.")),(0,i.kt)("h3",{id:"date-casting"},"Date Casting"),(0,i.kt)("p",null,"By default, TinyORM will cast the ",(0,i.kt)("inlineCode",{parentName:"p"},"created_at")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"updated_at")," columns to instances of ",(0,i.kt)("inlineCode",{parentName:"p"},"QDateTime"),". You may cast additional date attributes by defining additional date casts within your model's ",(0,i.kt)("inlineCode",{parentName:"p"},"u_casts")," data member unordered map. Typically, dates should be cast using the ",(0,i.kt)("inlineCode",{parentName:"p"},"CastType::QDateTime"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"CastType::QDate"),", or ",(0,i.kt)("inlineCode",{parentName:"p"},"CastType::Timestamp")," cast types."),(0,i.kt)("p",null,"When a database column is of the date type, you may set the corresponding model attribute value to a UNIX timestamp, date string (",(0,i.kt)("inlineCode",{parentName:"p"},"Y-m-d"),"), date-time string, or a ",(0,i.kt)("inlineCode",{parentName:"p"},"QDateTime")," instance. The date's value will be correctly converted and stored in your database.",(0,i.kt)("br",null),"\nThe same is true for the datetime or timestamp database column types, you can set the corresponding model attribute value to a UNIX timestamp, date-time string, or a ",(0,i.kt)("inlineCode",{parentName:"p"},"QDateTime")," instance."),(0,i.kt)("p",null,"To specify the format that should be used when actually storing a model's dates within your database, you should define a ",(0,i.kt)("inlineCode",{parentName:"p"},"u_dateFormat")," data member on your model:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"/*! The storage format of the model's date columns. */\ninline static QString u_dateFormat {QLatin1Char('U')};\n")),(0,i.kt)("p",null,"This format can be any format that the QDateTime's ",(0,i.kt)("inlineCode",{parentName:"p"},"fromString")," or ",(0,i.kt)("inlineCode",{parentName:"p"},"toString")," methods accept or the special ",(0,i.kt)("inlineCode",{parentName:"p"},"U")," format that represents the UNIX timestamp (this ",(0,i.kt)("inlineCode",{parentName:"p"},"U")," format is TinyORM specific and isn't supported by ",(0,i.kt)("inlineCode",{parentName:"p"},"QDateTime"),")."),(0,i.kt)("h3",{id:"query-time-casting"},"Query Time Casting"),(0,i.kt)("p",null,"Sometimes you may need to apply casts while executing a query, such as when selecting a raw value from a table. For example, consider the following query:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},'using Models::Post;\nusing Models::User;\n\nauto users = User::select("users.*")\n             ->addSelect(\n                 Post::selectRaw("MAX(created_at)")\n                     ->whereColumnEq("user_id", "users.id")\n                     .toBase(),\n                 "last_posted_at"\n             ).get();\n')),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"last_posted_at")," attribute on the results of this query will be a simple string. It would be wonderful if we could apply a ",(0,i.kt)("inlineCode",{parentName:"p"},"CastType::QDateTime")," cast to this attribute when executing the query. Thankfully, we may accomplish this using the ",(0,i.kt)("inlineCode",{parentName:"p"},"withCasts")," or ",(0,i.kt)("inlineCode",{parentName:"p"},"withCast")," methods:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},'auto users = User::select("users.*")\n             ->addSelect(Post::selectRaw("MAX(created_at)")\n                             ->whereColumnEq("user_id", "users.id")\n                             .toBase(),\n                         "last_posted_at")\n             .withCast({"last_posted_at", CastType::QDateTime})\n             .get();\n')))}d.isMDXComponent=!0}}]);