"use strict";(self.webpackChunktinyorm_org=self.webpackChunktinyorm_org||[]).push([[638],{3156:(e,n,o)=>{o.r(n),o.d(n,{assets:()=>l,contentTitle:()=>a,default:()=>c,frontMatter:()=>i,metadata:()=>r,toc:()=>d});var s=o(4848),t=o(8453);const i={sidebar_position:1,sidebar_label:"Relationships",description:"TinyORM relationships are defined as methods on your TinyORM model classes. Since relationships also serve as powerful query builders, defining relationships as methods provides powerful method chaining and querying capabilities.",keywords:["c++ orm","relationships","relations","tinyorm"]},a="TinyORM: Relationships",r={id:"tinyorm/relationships",title:"TinyORM: Relationships",description:"TinyORM relationships are defined as methods on your TinyORM model classes. Since relationships also serve as powerful query builders, defining relationships as methods provides powerful method chaining and querying capabilities.",source:"@site/docs/tinyorm/relationships.mdx",sourceDirName:"tinyorm",slug:"/tinyorm/relationships",permalink:"/tinyorm/relationships",draft:!1,unlisted:!1,tags:[],version:"current",sidebarPosition:1,frontMatter:{sidebar_position:1,sidebar_label:"Relationships",description:"TinyORM relationships are defined as methods on your TinyORM model classes. Since relationships also serve as powerful query builders, defining relationships as methods provides powerful method chaining and querying capabilities.",keywords:["c++ orm","relationships","relations","tinyorm"]},sidebar:"tinyormSidebar",previous:{title:"Getting Started",permalink:"/tinyorm/getting-started"},next:{title:"Collections",permalink:"/tinyorm/collections"}},l={},d=[{value:"Introduction",id:"introduction",level:2},{value:"Defining Relationships",id:"defining-relationships",level:2},{value:"Common Rules",id:"common-rules",level:3},{value:"One To One",id:"one-to-one",level:3},{value:"Defining The Inverse Of The Relationship",id:"defining-the-inverse-of-the-relationship",level:4},{value:"One To Many",id:"one-to-many",level:3},{value:"One To Many (Inverse) / Belongs To",id:"one-to-many-inverse",level:3},{value:"Default Models",id:"default-models",level:4},{value:"Many To Many Relationships",id:"many-to-many",level:2},{value:"Table Structure",id:"table-structure",level:4},{value:"Model Structure",id:"model-structure",level:4},{value:"Defining The Inverse Of The Relationship",id:"defining-the-inverse-of-the-relationship-1",level:4},{value:"Retrieving Intermediate Table Columns",id:"retrieving-intermediate-table-columns",level:3},{value:"Customizing The <code>pivot</code> Relation Name",id:"customizing-the-pivot-relation-name",level:4},{value:"Defining Custom Intermediate Table Models",id:"defining-custom-intermediate-table-models",level:3},{value:"Custom Pivot Models And Incrementing IDs",id:"custom-pivot-models-and-incrementing-ids",level:4},{value:"Closer Look At Defining Custom Intermediate Table Models",id:"closer-look-at-defining-custom-intermediate-table-models",level:4},{value:"User Data Members on Custom Intermediate Table Models",id:"user-data-members-on-custom-intermediate-table-models",level:5},{value:"Querying Relations",id:"querying-relations",level:2},{value:"Chaining <code>orWhere</code> Clauses After Relationships",id:"chaining-orwhere-clauses-after-relationships",level:4},{value:"Relationship Methods",id:"relationship-methods",level:3},{value:"Querying Relationship Existence",id:"querying-relationship-existence",level:3},{value:"Related template parameter",id:"related-template-parameter",level:4},{value:"Querying Relationship Absence",id:"querying-relationship-absence",level:3},{value:"Eager Loading",id:"eager-loading",level:2},{value:"Eager Loading Multiple Relationships",id:"eager-loading-multiple-relationships",level:4},{value:"Nested Eager Loading",id:"nested-eager-loading",level:4},{value:"Eager Loading Specific Columns",id:"eager-loading-specific-columns",level:4},{value:"Eager Loading By Default",id:"eager-loading-by-default",level:4},{value:"Constraining Eager Loads",id:"constraining-eager-loads",level:3},{value:"Lazy Eager Loading",id:"lazy-eager-loading",level:3},{value:"Inserting &amp; Updating Related Models",id:"inserting-and-updating-related-models",level:2},{value:"The <code>save</code> Method",id:"the-save-method",level:3},{value:"Recursively Saving Models &amp; Relationships",id:"recursively-saving-models--relationships",level:4},{value:"The <code>create</code> Method",id:"the-create-method",level:3},{value:"Belongs To Relationships",id:"updating-belongs-to-relationships",level:3},{value:"Many To Many Relationships",id:"updating-many-to-many-relationships",level:3},{value:"Attaching / Detaching",id:"attaching--detaching",level:4},{value:"Syncing Associations",id:"syncing-associations",level:4},{value:"Updating A Record On The Intermediate Table",id:"updating-a-record-on-the-intermediate-table",level:4},{value:"Touching Parent Timestamps",id:"touching-parent-timestamps",level:2}];function h(e){const n={a:"a",admonition:"admonition",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",h4:"h4",h5:"h5",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,t.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.h1,{id:"tinyorm-relationships",children:"TinyORM: Relationships"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#introduction",children:"Introduction"})}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.a,{href:"#defining-relationships",children:"Defining Relationships"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#common-rules",children:"Common Rules"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#one-to-one",children:"One To One"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#one-to-many",children:"One To Many"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#one-to-many-inverse",children:"One To Many (Inverse) / Belongs To"})}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.a,{href:"#many-to-many",children:"Many To Many Relationships"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#retrieving-intermediate-table-columns",children:"Retrieving Intermediate Table Columns"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#defining-custom-intermediate-table-models",children:"Defining Custom Intermediate Table Models"})}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.a,{href:"#querying-relations",children:"Querying Relations"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#relationship-methods",children:"Relationship Methods"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#querying-relationship-existence",children:"Querying Relationship Existence"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#querying-relationship-absence",children:"Querying Relationship Absence"})}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.a,{href:"#eager-loading",children:"Eager Loading"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#constraining-eager-loads",children:"Constraining Eager Loads"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#lazy-eager-loading",children:"Lazy Eager Loading"})}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.a,{href:"#inserting-and-updating-related-models",children:"Inserting & Updating Related Models"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:(0,s.jsxs)(n.a,{href:"#the-save-method",children:["The ",(0,s.jsx)(n.code,{children:"save"})," Method"]})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsxs)(n.a,{href:"#the-create-method",children:["The ",(0,s.jsx)(n.code,{children:"create"})," Method"]})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#updating-belongs-to-relationships",children:"Belongs To Relationships"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#updating-many-to-many-relationships",children:"Many To Many Relationships"})}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#touching-parent-timestamps",children:"Touching Parent Timestamps"})}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"introduction",children:"Introduction"}),"\n",(0,s.jsx)(n.p,{children:"Database tables are often related to one another. For example, a blog post may have many comments or an order could be related to the user who placed it. TinyORM makes managing and working with these relationships easy, and supports basic relationships:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#one-to-one",children:"One To One"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#one-to-many",children:"One To Many"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#many-to-many",children:"Many To Many"})}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"defining-relationships",children:"Defining Relationships"}),"\n",(0,s.jsxs)(n.p,{children:["TinyORM relationships are defined as methods on your TinyORM model classes. Since relationships also serve as powerful ",(0,s.jsx)(n.a,{href:"/database/query-builder",children:"query builders"}),", defining relationships as methods provides powerful method chaining and querying capabilities. For example, we may chain additional query constraints on this ",(0,s.jsx)(n.code,{children:"posts"})," relationship:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:'user->posts()->whereEq("active", 1).get();\n'})}),"\n",(0,s.jsx)(n.p,{children:"But, before diving too deep into using relationships, let's learn how to define each type of relationship supported by TinyORM."}),"\n",(0,s.jsx)(n.h3,{id:"common-rules",children:"Common Rules"}),"\n",(0,s.jsx)(n.p,{children:'Before you start defining relationship methods, you have to declare a model class, let\'s examine following model class with a "one" type relation:'}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:'#pragma once\n#ifndef USER_HPP\n#define USER_HPP\n\n#include <orm/tiny/model.hpp>\n\n#include "models/phone.hpp"\n\nusing Orm::Tiny::Model;\n\nclass User final : public Model<User, Phone>\n{\n    friend Model;\n    using Model::Model;\n\npublic:\n    /*! Get the phone associated with the user. */\n    std::unique_ptr<HasOne<User, Phone>>\n    phone()\n    {\n        return hasOne<Phone>();\n    }\n\nprivate:\n    /*! Map of relation names to methods. */\n    QHash<QString, RelationVisitor> u_relations {\n        {"phone", &User::phone); }},\n    };\n};\n\n#endif // USER_HPP\n'})}),"\n",(0,s.jsxs)(n.p,{children:["First, you have to extend the ",(0,s.jsx)(n.code,{children:"Model<Derived, AllRelations...>"}),", it is a common class for all models, the first template parameter is the type-id of the defined model itself, this pattern is called a ",(0,s.jsx)(n.a,{href:"https://en.wikipedia.org/wiki/Curiously_recurring_template_pattern",children:"Curiously recurring template pattern"})," pattern."]}),"\n",(0,s.jsx)(n.p,{children:"However, the second parameter is more interesting, here you have to provide a type-id of all related models. The TinyORM needs these types to store relationships in the hash."}),"\n",(0,s.jsxs)(n.p,{children:["Next, you have to define the ",(0,s.jsx)(n.code,{children:"u_relations"})," hash, which maps relation names to relationship methods. \ud83d\udd25\ud83d\ude80\ud83d\ude4c"]}),"\n",(0,s.jsx)(n.admonition,{type:"tip",children:(0,s.jsxs)(n.p,{children:["You may omit the ",(0,s.jsx)(n.code,{children:"friend Model"})," declaration and define all the private data and function members as public."]})}),"\n",(0,s.jsx)(n.h3,{id:"one-to-one",children:"One To One"}),"\n",(0,s.jsxs)(n.p,{children:["A one-to-one relationship is a very basic type of database relationship. For example, a ",(0,s.jsx)(n.code,{children:"User"})," model might be associated with one ",(0,s.jsx)(n.code,{children:"Phone"})," model. To define this relationship, we will place a ",(0,s.jsx)(n.code,{children:"phone"})," method on the ",(0,s.jsx)(n.code,{children:"User"})," model. The ",(0,s.jsx)(n.code,{children:"phone"})," method should call the ",(0,s.jsx)(n.code,{children:"hasOne"})," method and return its result. The ",(0,s.jsx)(n.code,{children:"hasOne<Related>"})," method is available to your model via the model's ",(0,s.jsx)(n.code,{children:"Orm::Tiny::Model<Derived, AllRelations...>"})," base class:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:'#pragma once\n#ifndef USER_HPP\n#define USER_HPP\n\n#include <orm/tiny/model.hpp>\n\n#include "models/phone.hpp"\n\nusing Orm::Tiny::Model;\n\nclass User final : public Model<User, Phone>\n{\n    friend Model;\n    using Model::Model;\n\npublic:\n    /*! Get the phone associated with the user. */\n    std::unique_ptr<HasOne<User, Phone>>\n    phone()\n    {\n        return hasOne<Phone>();\n    }\n\nprivate:\n    /*! Map of relation names to methods. */\n    QHash<QString, RelationVisitor> u_relations {\n        {"phone", [](auto &v) { v(&User::phone); }},\n    };\n};\n\n#endif // USER_HPP\n'})}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.code,{children:"Related"})," template argument provided to the ",(0,s.jsx)(n.code,{children:"hasOne<Related>"})," method is the type-id of the related model class. Once the relationship is defined, we may retrieve the related record using Model's ",(0,s.jsx)(n.code,{children:"getRelationValue<Related, Tag>"})," method:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:'auto phone = User::find(1)->getRelationValue<Phone, Orm::One>("phone");\n'})}),"\n",(0,s.jsxs)(n.p,{children:["TinyORM determines the foreign key of the relationship based on the parent model name. In this case, the ",(0,s.jsx)(n.code,{children:"Phone"})," model is automatically assumed to have a ",(0,s.jsx)(n.code,{children:"user_id"})," foreign key. If you wish to override this convention, you may pass a first argument to the ",(0,s.jsx)(n.code,{children:"hasOne"})," method:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:'return hasOne<Phone>("foreign_key");\n'})}),"\n",(0,s.jsxs)(n.p,{children:["Additionally, TinyORM assumes that the foreign key should have a value matching the primary key column of the parent. In other words, TinyORM will look for the value of the user's ",(0,s.jsx)(n.code,{children:"id"})," column in the ",(0,s.jsx)(n.code,{children:"user_id"})," column of the ",(0,s.jsx)(n.code,{children:"Phone"})," record. If you would like the relationship to use a primary key value other than ",(0,s.jsx)(n.code,{children:"id"})," or your model's ",(0,s.jsx)(n.code,{children:"u_primaryKey"})," data member, you may pass a second argument to the ",(0,s.jsx)(n.code,{children:"hasOne"})," method:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:'return hasOne<Phone>("foreign_key", "local_key");\n'})}),"\n",(0,s.jsx)(n.h4,{id:"defining-the-inverse-of-the-relationship",children:"Defining The Inverse Of The Relationship"}),"\n",(0,s.jsxs)(n.p,{children:["So, we can access the ",(0,s.jsx)(n.code,{children:"Phone"})," model from our ",(0,s.jsx)(n.code,{children:"User"})," model. Next, let's define a relationship on the ",(0,s.jsx)(n.code,{children:"Phone"})," model that will let us access the user that owns the phone. We can define the inverse of a ",(0,s.jsx)(n.code,{children:"hasOne"})," relationship using the ",(0,s.jsx)(n.code,{children:"belongsTo<Related>"})," method:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:'#pragma once\n#ifndef PHONE_HPP\n#define PHONE_HPP\n\n#include <orm/tiny/model.hpp>\n\n#include "models/user.hpp"\n\nusing Orm::Tiny::Model;\n\nclass Phone final : public Model<Phone, User>\n{\n    friend Model;\n    using Model::Model;\n\npublic:\n    /*! Get the user that owns the phone. */\n    std::unique_ptr<BelongsTo<Phone, User>>\n    user()\n    {\n        return belongsTo<User>();\n    }\n\nprivate:\n    /*! Map of relation names to methods. */\n    QHash<QString, RelationVisitor> u_relations {\n        {"user", [](auto &v) { v(&Phone::user); }},\n    };\n};\n\n#endif // PHONE_HPP\n'})}),"\n",(0,s.jsxs)(n.p,{children:["When invoking the ",(0,s.jsx)(n.code,{children:"user"})," method, TinyORM will attempt to find a ",(0,s.jsx)(n.code,{children:"User"})," model that has an ",(0,s.jsx)(n.code,{children:"id"})," which matches the ",(0,s.jsx)(n.code,{children:"user_id"})," column on the ",(0,s.jsx)(n.code,{children:"Phone"})," model."]}),"\n",(0,s.jsxs)(n.p,{children:["TinyORM determines the foreign key name by examining the type-name of the ",(0,s.jsx)(n.code,{children:"Related"})," template parameter and suffixing the type-name with ",(0,s.jsx)(n.code,{children:"_id"}),". So, in this case, TinyORM assumes that the ",(0,s.jsx)(n.code,{children:"Phone"})," model has a ",(0,s.jsx)(n.code,{children:"user_id"})," column."]}),"\n",(0,s.jsxs)(n.p,{children:["However, if the foreign key on the ",(0,s.jsx)(n.code,{children:"Phone"})," model is not ",(0,s.jsx)(n.code,{children:"user_id"}),", you may pass a custom key name as the first argument to the ",(0,s.jsx)(n.code,{children:"belongsTo"})," method:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:'/*! Get the user that owns the phone. */\nstd::unique_ptr<BelongsTo<Phone, User>>\nuser()\n{\n    return belongsTo<User>("foreign_key");\n}\n'})}),"\n",(0,s.jsxs)(n.p,{children:["If the parent model does not use ",(0,s.jsx)(n.code,{children:"id"})," as its primary key, or you wish to find the associated model using a different column, you may pass a second argument to the ",(0,s.jsx)(n.code,{children:"belongsTo"})," method specifying the parent table's custom key:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:'/*! Get the user that owns the phone. */\nstd::unique_ptr<BelongsTo<Phone, User>>\nuser()\n{\n    return belongsTo<User>("foreign_key", "owner_key");\n}\n'})}),"\n",(0,s.jsxs)(n.p,{children:["The third ",(0,s.jsx)(n.code,{children:"belongsTo"}),' parameter is the relation name, if you pass it, the foreign key name will be determined from it. By convention, TinyORM will "snake_case" this relation name  and suffix it with a ',(0,s.jsx)(n.code,{children:"_"})," followed by the name of the parent model's primary key column to generate foreign key, the ",(0,s.jsx)(n.code,{children:"__func__"})," predefined identifier is ideal for this. The relation name is also used in BelongsTo's ",(0,s.jsx)(n.code,{children:"associate"})," and ",(0,s.jsx)(n.code,{children:"disassociate"})," methods:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:"/*! Get the user that owns the phone. */\nstd::unique_ptr<BelongsTo<Phone, User>>\nsomeUser()\n{\n    return belongsTo<User>({}, {}, QString::fromUtf8(__func__)); // the foreign key will be some_user_id\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["The relation name will be guessed from the type-id of the ",(0,s.jsx)(n.code,{children:"Related"})," template parameter, TinyORM takes this name and changes the first character to lower case, so in the example above, the relation name will be ",(0,s.jsx)(n.code,{children:"user"}),"."]}),"\n",(0,s.jsx)(n.h3,{id:"one-to-many",children:"One To Many"}),"\n",(0,s.jsxs)(n.p,{children:["A one-to-many relationship is used to define relationships where a single model is the parent to one or more child models. For example, a blog post may have an infinite number of comments. Like all other TinyORM relationships, one-to-many relationships are defined by defining a ",(0,s.jsx)(n.code,{children:"hasMany<Related>"})," method on your TinyORM model:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:'#pragma once\n#ifndef POST_HPP\n#define POST_HPP\n\n#include <orm/tiny/model.hpp>\n\n#include "models/comment.hpp"\n\nusing Orm::Tiny::Model;\n\nclass Post final : public Model<Post, Comment>\n{\n    friend Model;\n    using Model::Model;\n\npublic:\n    /*! Get the comments for the blog post. */\n    std::unique_ptr<HasMany<Post, Comment>>\n    comments()\n    {\n        return hasMany<Comment>();\n    }\n\nprivate:\n    /*! Map of relation names to methods. */\n    QHash<QString, RelationVisitor> u_relations {\n        {"comments", [](auto &v) { v(&Post::comments); }},\n    };\n};\n\n#endif // POST_HPP\n'})}),"\n",(0,s.jsxs)(n.p,{children:["Remember, TinyORM will automatically determine the proper foreign key column for the ",(0,s.jsx)(n.code,{children:"Comment"}),' model. By convention, TinyORM will take the "snake_case" name of the parent model and suffix it with ',(0,s.jsx)(n.code,{children:"_id"}),". So, in this example, TinyORM will assume the foreign key column on the ",(0,s.jsx)(n.code,{children:"Comment"})," model is ",(0,s.jsx)(n.code,{children:"post_id"}),"."]}),"\n",(0,s.jsxs)(n.p,{children:["Once the relationship method has been defined, we can access the ",(0,s.jsx)(n.code,{children:"QVector<Related *>"})," of related comments by Model's ",(0,s.jsx)(n.code,{children:"getRelationValue<Related, Container = QVector>"})," method:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:'#include "models/post.hpp"\n\nauto comments = Post::find(1)->getRelationValue<Comment>("comments");\n\nfor (auto *comment : comments) {\n    //\n}\n'})}),"\n",(0,s.jsxs)(n.p,{children:["Since all relationships also serve as ",(0,s.jsx)(n.a,{href:"/database/query-builder",children:"query builders"}),", you may add further constraints to the relationship query by calling the ",(0,s.jsx)(n.code,{children:"comments"})," method and continuing to chain conditions onto the query, all the ",(0,s.jsx)(n.code,{children:"TinyBuilder"})," methods which are related to building queries are proxied:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:'auto comment = Post::find(1)->comments()\n                     ->whereEq("title", "foo")\n                     .first();\n'})}),"\n",(0,s.jsxs)(n.p,{children:["Like the ",(0,s.jsx)(n.code,{children:"hasOne"})," method, you may also override the foreign and local keys by passing additional arguments to the ",(0,s.jsx)(n.code,{children:"hasMany"})," method:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:'return hasMany<Comment>("foreign_key");\n\nreturn hasMany<Comment>("foreign_key", "local_key");\n'})}),"\n",(0,s.jsx)(n.h3,{id:"one-to-many-inverse",children:"One To Many (Inverse) / Belongs To"}),"\n",(0,s.jsxs)(n.p,{children:["Now that we can access all of a post's comments, let's define a relationship to allow a comment to access its parent post. To define the inverse of a ",(0,s.jsx)(n.code,{children:"hasMany"})," relationship, define a relationship method on the child model which calls the ",(0,s.jsx)(n.code,{children:"belongsTo"})," method:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:'#pragma once\n#ifndef COMMENT_HPP\n#define COMMENT_HPP\n\n#include <orm/tiny/model.hpp>\n\n#include "models/post.hpp"\n\nusing Orm::Tiny::Model;\n\nclass Comment final : public Model<Comment, Post>\n{\n    friend Model;\n    using Model::Model;\n\npublic:\n    /*! Get the post that owns the comment. */\n    std::unique_ptr<BelongsTo<Comment, Post>>\n    post()\n    {\n        return belongsTo<Post>();\n    }\n\nprivate:\n    /*! Map of relation names to methods. */\n    QHash<QString, RelationVisitor> u_relations {\n        {"post", [](auto &v) { v(&Comment::post); }},\n    };\n};\n\n#endif // COMMENT_HPP\n'})}),"\n",(0,s.jsxs)(n.p,{children:["Once the relationship has been defined, we can retrieve a comment's parent post by Model's ",(0,s.jsx)(n.code,{children:"getRelationValue<Related, Tag>"})," method:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:'#include "models/comment.hpp"\n\nauto comment = Comment::find(1);\n\nreturn comment->getRelationValue<Post, Orm::One>("post")->getAttribute<QString>("title");\n'})}),"\n",(0,s.jsxs)(n.p,{children:["In the example above, TinyORM will attempt to find a ",(0,s.jsx)(n.code,{children:"Post"})," model that has an ",(0,s.jsx)(n.code,{children:"id"})," which matches the ",(0,s.jsx)(n.code,{children:"post_id"})," column on the ",(0,s.jsx)(n.code,{children:"Comment"})," model."]}),"\n",(0,s.jsxs)(n.p,{children:["TinyORM determines the foreign key name by examining the type-name of the ",(0,s.jsx)(n.code,{children:"Related"})," template parameter and suffixing the type-name with a ",(0,s.jsx)(n.code,{children:"_"})," followed by the name of the parent model's primary key column. So, in this case, TinyORM assumes that the ",(0,s.jsx)(n.code,{children:"Post"})," model's foreign key on the ",(0,s.jsx)(n.code,{children:"comments"})," table is ",(0,s.jsx)(n.code,{children:"post_id"}),"."]}),"\n",(0,s.jsxs)(n.p,{children:["However, if the foreign key for your relationship does not follow these conventions, you may pass a custom foreign key name as the first argument to the ",(0,s.jsx)(n.code,{children:"belongsTo"})," method:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:'/*! Get the post that owns the comment. */\nstd::unique_ptr<BelongsTo<Comment, Post>>\npost()\n{\n    return belongsTo<Post>("foreign_key");\n}\n'})}),"\n",(0,s.jsxs)(n.p,{children:["If your parent model does not use ",(0,s.jsx)(n.code,{children:"id"})," as its primary key, or you wish to find the associated model using a different column, you may pass a second argument to the ",(0,s.jsx)(n.code,{children:"belongsTo"})," method specifying your parent table's custom key:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:'/*! Get the post that owns the comment. */\nstd::unique_ptr<BelongsTo<Comment, Post>>\npost()\n{\n    return belongsTo<Post>("foreign_key", "owner_key");\n}\n'})}),"\n",(0,s.jsxs)(n.p,{children:["The third ",(0,s.jsx)(n.code,{children:"belongsTo"}),' parameter is the relation name, if you pass it, the foreign key name will be determined from it. By convention, TinyORM will "snake_case" this relation name  and suffix it with a ',(0,s.jsx)(n.code,{children:"_"})," followed by the name of the parent model's primary key column to generate foreign key, the ",(0,s.jsx)(n.code,{children:"__func__"})," predefined identifier is ideal for this. The relation name is also used in BelongsTo's ",(0,s.jsx)(n.code,{children:"associate"})," and ",(0,s.jsx)(n.code,{children:"disassociate"})," methods:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:"/*! Get the post that owns the comment. */\nstd::unique_ptr<BelongsTo<Comment, Post>>\nsomePost()\n{\n    return belongsTo<Post>({}, {}, QString::fromUtf8(__func__)); // the foreign key will be some_post_id\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["The relation name will be guessed from the type-id of the ",(0,s.jsx)(n.code,{children:"Related"})," template parameter, TinyORM takes this name and changes the first character to lower case, so in the example above, the relation name will be ",(0,s.jsx)(n.code,{children:"user"}),"."]}),"\n",(0,s.jsx)(n.h4,{id:"default-models",children:"Default Models"}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.code,{children:"belongsTo"}),", and ",(0,s.jsx)(n.code,{children:"hasOne"})," relationships allow you to define a default model that will be returned if the given relationship is ",(0,s.jsx)(n.code,{children:"null"}),". This pattern is often referred to as the ",(0,s.jsx)(n.a,{href:"https://en.wikipedia.org/wiki/Null_Object_pattern",children:"Null Object pattern"})," and can help remove conditional checks in your code. In the following example, the ",(0,s.jsx)(n.code,{children:"user"})," relation will return an empty ",(0,s.jsx)(n.code,{children:"User"})," model if no user is attached to the ",(0,s.jsx)(n.code,{children:"Post"})," model:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:"/*! Get the author of the post. */\nstd::unique_ptr<BelongsTo<Post, User>>\nuser()\n{\n    // Ownership of a unique_ptr()\n    auto relation = belongsTo<User>();\n\n    relation->withDefault();\n\n    return relation;\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["To populate the default model with attributes, you may pass the vector of attributes to the ",(0,s.jsx)(n.code,{children:"withDefault"})," method:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:'/*! Get the author of the post. */\nstd::unique_ptr<BelongsTo<Post, User>>\nuser()\n{\n    // Ownership of a unique_ptr()\n    auto relation = belongsTo<User>();\n\n    relation->withDefault({{"name", "Guest Author"},\n                           {"is_active", false}});\n\n    return relation;\n}\n'})}),"\n",(0,s.jsx)(n.h2,{id:"many-to-many",children:"Many To Many Relationships"}),"\n",(0,s.jsxs)(n.p,{children:["Many-to-many relations are slightly more complicated than ",(0,s.jsx)(n.code,{children:"hasOne"})," and ",(0,s.jsx)(n.code,{children:"hasMany"}),' relationships. An example of a many-to-many relationship is a user that has many roles and those roles are also shared by other users in the application. For example, a user may be assigned the role of "Author" and "Editor"; however, those roles may also be assigned to other users as well. So, a user has many roles and a role has many users.']}),"\n",(0,s.jsx)(n.h4,{id:"table-structure",children:"Table Structure"}),"\n",(0,s.jsxs)(n.p,{children:["To define this relationship, three database tables are needed: ",(0,s.jsx)(n.code,{children:"users"}),", ",(0,s.jsx)(n.code,{children:"roles"}),", and ",(0,s.jsx)(n.code,{children:"role_user"}),". The ",(0,s.jsx)(n.code,{children:"role_user"})," table is derived from the alphabetical order of the related model names and contains ",(0,s.jsx)(n.code,{children:"user_id"})," and ",(0,s.jsx)(n.code,{children:"role_id"})," columns. This table is used as an intermediate table linking the users and roles."]}),"\n",(0,s.jsxs)(n.p,{children:["Remember, since a role can belong to many users, we cannot simply place a ",(0,s.jsx)(n.code,{children:"user_id"})," column on the ",(0,s.jsx)(n.code,{children:"roles"})," table. This would mean that a role could only belong to a single user. In order to provide support for roles being assigned to multiple users, the ",(0,s.jsx)(n.code,{children:"role_user"})," table is needed. We can summarize the relationship's table structure like so:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-text",children:"users\n  id - integer\n  name - string\n\nroles\n  id - integer\n  name - string\n\nrole_user\n  user_id - integer\n  role_id - integer\n"})}),"\n",(0,s.jsx)(n.h4,{id:"model-structure",children:"Model Structure"}),"\n",(0,s.jsxs)(n.p,{children:["Many-to-many relationships are defined by writing a method that returns the result of the ",(0,s.jsx)(n.code,{children:"belongsToMany"})," method. The ",(0,s.jsx)(n.code,{children:"belongsToMany"})," method is provided by the ",(0,s.jsx)(n.code,{children:"Orm::Tiny::Model<Derived, AllRelations...>"})," base class that is used by all of your application's TinyORM models. For example, let's define a ",(0,s.jsx)(n.code,{children:"roles"})," method on our ",(0,s.jsx)(n.code,{children:"User"})," model. The first argument passed to this method is the name of the related model class:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:'#pragma once\n#ifndef USER_HPP\n#define USER_HPP\n\n#include <orm/tiny/relations/pivot.hpp>\n\n#include "models/role.hpp"\n\nusing Orm::Tiny::Model;\nusing Orm::Tiny::Relations::Pivot;\n\nclass User final : public Model<User, Role, Pivot>\n{\n    friend Model;\n    using Model::Model;\n\npublic:\n    /*! The roles that belong to the user. */\n    std::unique_ptr<BelongsToMany<User, Role>>\n    roles()\n    {\n        return belongsToMany<Role>();\n    }\n\nprivate:\n    /*! Map of relation names to methods. */\n    QHash<QString, RelationVisitor> u_relations {\n        {"roles", [](auto &v) { v(&User::roles); }},\n    };\n};\n\n#endif // USER_HPP\n'})}),"\n",(0,s.jsxs)(n.p,{children:["Once the relationship is defined, you may access the user's roles as the ",(0,s.jsx)(n.code,{children:"QVector<Related *>"}),"  by Model's ",(0,s.jsx)(n.code,{children:"getRelationValue<Related, Container = QVector>"})," method:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:'#include <QDebug>\n\n#include "models/user.hpp"\n\nauto user = User::find(1);\n\nfor (auto *role : user->getRelationValue<Role>("roles"))\n    qDebug() << role->getAttribute<quint64>("id");\n'})}),"\n",(0,s.jsxs)(n.p,{children:["Since all relationships also serve as query builders, you may add further constraints to the relationship query by calling the ",(0,s.jsx)(n.code,{children:"roles"})," method and continuing to chain conditions onto the query:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:'auto roles = User::find(1)->roles()->orderBy("name").get();\n'})}),"\n",(0,s.jsxs)(n.p,{children:["To determine the table name of the relationship's intermediate table, TinyORM will join the two related model names in alphabetical order. However, you are free to override this convention. You may do so by passing a first argument to the ",(0,s.jsx)(n.code,{children:"belongsToMany"})," method:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:'return belongsToMany<Role>("role_user");\n'})}),"\n",(0,s.jsxs)(n.p,{children:["In addition to customizing the name of the intermediate table, you may also customize the column names of the keys on the table by passing additional arguments to the ",(0,s.jsx)(n.code,{children:"belongsToMany"})," method. The second argument is the foreign key name of the model on which you are defining the relationship, while the third argument is the foreign key name of the model that you are joining to:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:'return belongsToMany<Role>("role_user", "user_id", "role_id");\n'})}),"\n",(0,s.jsx)(n.p,{children:"The fourth and fifth arguments are primary key names on models in the many-to-many relation and the sixth argument is the relation name."}),"\n",(0,s.jsxs)(n.p,{children:["The relation name is used during ",(0,s.jsx)(n.a,{href:"#touching-parent-timestamps",children:"Touching Parent Timestamps"})," and will be guessed from the type-id of the ",(0,s.jsx)(n.code,{children:"Related"})," template parameter, TinyORM takes this name, changes the first character to lower case, and appends ",(0,s.jsx)(n.code,{children:"s"})," character. So in the example above, the relation name will be ",(0,s.jsx)(n.code,{children:"roles"}),"."]}),"\n",(0,s.jsx)(n.h4,{id:"defining-the-inverse-of-the-relationship-1",children:"Defining The Inverse Of The Relationship"}),"\n",(0,s.jsxs)(n.p,{children:['To define the "inverse" of a many-to-many relationship, you should define a method on the related model which also returns the result of the ',(0,s.jsx)(n.code,{children:"belongsToMany"})," method. To complete our user / role example, let's define the ",(0,s.jsx)(n.code,{children:"users"})," method on the ",(0,s.jsx)(n.code,{children:"Role"})," model:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:'#pragma once\n#ifndef ROLE_HPP\n#define ROLE_HPP\n\n#include <orm/tiny/relations/pivot.hpp>\n\nusing Orm::Tiny::Model;\nusing Orm::Tiny::Relations::Pivot;\n\nclass User; // Forward declaration to avoid cyclic dependency\n\nclass Role final : public Model<Role, User, Pivot>\n{\n    friend Model;\n    using Model::Model;\n\npublic:\n    /*! The users that belong to the role. */\n    std::unique_ptr<BelongsToMany<Role, User>>\n    users()\n    {\n        return belongsToMany<User>();\n    }\n\nprivate:\n    /*! Map of relation names to methods. */\n    QHash<QString, RelationVisitor> u_relations {\n        {"users", [](auto &v) { v(&Role::users); }},\n    };\n};\n\n#endif // ROLE_HPP\n'})}),"\n",(0,s.jsxs)(n.p,{children:["As you can see, the relationship is defined exactly the same as its ",(0,s.jsx)(n.code,{children:"User"})," model counterpart with the exception of referencing the ",(0,s.jsx)(n.code,{children:"User"})," model. Since we're reusing the ",(0,s.jsx)(n.code,{children:"belongsToMany"}),' method, all of the usual table and key customization options are available when defining the "inverse" of many-to-many relationships.']}),"\n",(0,s.jsx)(n.h3,{id:"retrieving-intermediate-table-columns",children:"Retrieving Intermediate Table Columns"}),"\n",(0,s.jsxs)(n.p,{children:["As you have already learned, working with many-to-many relations requires the presence of an intermediate table. TinyORM provides some very helpful ways of interacting with this table. For example, let's assume our ",(0,s.jsx)(n.code,{children:"User"})," model has many ",(0,s.jsx)(n.code,{children:"Role"})," models that it is related to. After accessing this relationship, we may access the intermediate table using the ",(0,s.jsx)(n.code,{children:"pivot"})," attribute on the models:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:'#include <QDebug>\n\n#include "models/user.hpp"\n\nusing Orm::Tiny::Relations::Pivot;\n\nauto user = User::find(1);\n\nfor (auto *role : user->getRelationValue<Role>("roles"))\n    qDebug() << role->getRelation<Pivot, Orm::One>("pivot")\n                ->getAttribute("created_at");\n'})}),"\n",(0,s.jsxs)(n.p,{children:["Notice that each ",(0,s.jsx)(n.code,{children:"Role"})," model we retrieve has automatically assigned a ",(0,s.jsx)(n.code,{children:"pivot"})," relationship. This relation contains a model representing the intermediate table and it is an instance of the ",(0,s.jsx)(n.code,{children:"Orm::Tiny::Relations::Pivot"})," model class."]}),"\n",(0,s.jsxs)(n.p,{children:["By default, only the model keys will be present on the ",(0,s.jsx)(n.code,{children:"pivot"})," model. If your intermediate table contains extra attributes, you must specify them when defining the relationship:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:'// Ownership of a unique_ptr()\nauto relation = belongsToMany<Role>();\n\nrelation->withPivot({"active", "created_by"});\n\nreturn relation;\n'})}),"\n",(0,s.jsxs)(n.p,{children:["If you would like your intermediate table to have ",(0,s.jsx)(n.code,{children:"created_at"})," and ",(0,s.jsx)(n.code,{children:"updated_at"})," timestamps that are automatically maintained by TinyORM, call the ",(0,s.jsx)(n.code,{children:"withTimestamps"})," method when defining the relationship:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:"// Ownership of a unique_ptr()\nauto relation = belongsToMany<Role>();\n\nrelation->withTimestamps();\n\nreturn relation;\n"})}),"\n",(0,s.jsx)(n.admonition,{type:"warning",children:(0,s.jsxs)(n.p,{children:["Intermediate tables that utilize TinyORM's automatically maintained timestamps are required to have both ",(0,s.jsx)(n.code,{children:"created_at"})," and ",(0,s.jsx)(n.code,{children:"updated_at"})," timestamp columns."]})}),"\n",(0,s.jsxs)(n.h4,{id:"customizing-the-pivot-relation-name",children:["Customizing The ",(0,s.jsx)(n.code,{children:"pivot"})," Relation Name"]}),"\n",(0,s.jsxs)(n.p,{children:["As noted previously, attributes from the intermediate table may be accessed on models via the ",(0,s.jsx)(n.code,{children:"pivot"})," relation name. However, you are free to customize the name of this relation to better reflect its purpose within your application."]}),"\n",(0,s.jsxs)(n.p,{children:["For example, if your application contains users that may subscribe to podcasts, you likely have a many-to-many relationship between users and podcasts. If this is the case, you may wish to rename your intermediate table relation name to ",(0,s.jsx)(n.code,{children:"subscription"})," instead of ",(0,s.jsx)(n.code,{children:"pivot"}),". This can be done using the ",(0,s.jsx)(n.code,{children:"as"})," method when defining the relationship:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:'// Ownership of a unique_ptr()\nauto relation = belongsToMany<Podcast>();\n\nrelation->as("subscription")\n        .withTimestamps();\n\nreturn relation;\n'})}),"\n",(0,s.jsx)(n.p,{children:"Once the custom intermediate table relation name has been specified, you may access the intermediate table data using the customized name:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:'#include <QDebug>\n\n#include "models/user.hpp"\n\nusing Orm::Tiny::Relations::Pivot;\n\nauto users = User::with("podcasts")->get();\n\nfor (auto &user : users)\n    for (auto *podcast : user.getRelation<Podcast>("podcasts"))\n        qDebug() << podcast->getRelation<Pivot, Orm::One>("subscription")\n                    ->getAttribute("created_at");\n'})}),"\n",(0,s.jsx)(n.h3,{id:"defining-custom-intermediate-table-models",children:"Defining Custom Intermediate Table Models"}),"\n",(0,s.jsxs)(n.p,{children:["If you would like to define a custom model to represent the intermediate table of your many-to-many relationship, you may pass the custom pivot type as a second template argument to the ",(0,s.jsx)(n.code,{children:"belongsToMany<Related, PivotType = Pivot>"})," method when defining the relationship. Custom pivot models give you the opportunity to define additional methods on the pivot model."]}),"\n",(0,s.jsxs)(n.p,{children:["Custom many-to-many pivot models should extend the ",(0,s.jsx)(n.code,{children:"Orm::Tiny::Relations::BasePivot<PivotModel>"})," class. For example, we may define a ",(0,s.jsx)(n.code,{children:"User"})," model which uses a custom ",(0,s.jsx)(n.code,{children:"RoleUser"})," pivot model:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:'#pragma once\n#ifndef USER_HPP\n#define USER_HPP\n\n#include <orm/tiny/relations/pivot.hpp>\n\n#include "models/role.hpp"\n\nusing Orm::Tiny::Model;\nusing Orm::Tiny::Relations::Pivot;\n\nclass User final : public Model<User, Role, Pivot>\n{\n    friend Model;\n    using Model::Model;\n\npublic:\n    /*! The roles that belong to the user. */\n    std::unique_ptr<BelongsToMany<User, Role, RoleUser>>\n    roles()\n    {\n        return belongsToMany<Role, RoleUser>();\n    }\n\nprivate:\n    /*! Map of relation names to methods. */\n    QHash<QString, RelationVisitor> u_relations {\n        {"roles", [](auto &v) { v(&User::roles); }},\n    };\n};\n\n#endif // USER_HPP\n'})}),"\n",(0,s.jsxs)(n.p,{children:["When defining the ",(0,s.jsx)(n.code,{children:"RoleUser"})," model, you should extend the ",(0,s.jsx)(n.code,{children:"Orm::Tiny::Relations::BasePivot<PivotModel>"})," class:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:"#pragma once\n#ifndef ROLEUSER_HPP\n#define ROLEUSER_HPP\n\n#include <orm/tiny/relations/basepivot.hpp>\n\nusing Orm::Tiny::Relations::BasePivot;\n\nclass RoleUser final : public BasePivot<RoleUser>\n{\n    friend Model;\n    friend BasePivot;\n\n    using BasePivot::BasePivot;\n};\n\n#endif // ROLEUSER_HPP\n"})}),"\n",(0,s.jsxs)(n.p,{children:["You have to pass a custom pivot type to the ",(0,s.jsx)(n.code,{children:"AllRelations"})," template parameter pack on ",(0,s.jsx)(n.code,{children:"Model<Derived, AllRelations...>"})," so that the ",(0,s.jsx)(n.code,{children:"Model"})," knows how to generate a ",(0,s.jsx)(n.code,{children:"std::variant"}),", which holds all the relations and also you have to add a new mapping from the relation name to the custom pivot model type-id, this is  described in more detail in the ",(0,s.jsx)(n.a,{href:"#common-rules",children:"Common Rules"}),":"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:'#pragma once\n#ifndef ROLE_HPP\n#define ROLE_HPP\n\n#include <orm/tiny/model.hpp>\n\n#include "models/roleuser.hpp"\n\nusing Orm::Tiny::Model;\n\nclass User; // Forward declaration to avoid cyclic dependency\n\nclass Role final : public Model<Role, User, RoleUser>\n{\n    friend Model;\n    using Model::Model;\n\npublic:\n    /*! The users that belong to the role. */\n    std::unique_ptr<BelongsToMany<Role, User>>\n    users()\n    {\n        return belongsToMany<User>();\n    }\n\nprivate:\n    /*! Map of relation names to methods. */\n    QHash<QString, RelationVisitor> u_relations {\n        {"users", [](auto &v) { v(&Role::users); }},\n    };\n};\n\n#endif // ROLE_HPP\n'})}),"\n",(0,s.jsxs)(n.p,{children:["Once the custom pivot model ",(0,s.jsx)(n.code,{children:"RoleUser"})," has been defined, ",(0,s.jsx)(n.code,{children:"getRelation"})," or ",(0,s.jsx)(n.code,{children:"getRelationValue"})," method returns proper pivot type:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:'#include <QDebug>\n\n#include "models/user.hpp"\n\nauto users = User::with("roles")->get();\n\nfor (auto &user : users)\n    for (auto *role : user.getRelation<Role>("roles"))\n        qDebug() << role->getRelation<RoleUser, Orm::One>("pivot")\n                    ->getAttribute("created_at");\n'})}),"\n",(0,s.jsx)(n.admonition,{type:"warning",children:(0,s.jsxs)(n.p,{children:["Custom Pivot models may not use the ",(0,s.jsx)(n.code,{children:"SoftDeletes"})," base class. If you need to soft delete pivot records consider converting your pivot model to an actual TinyORM model."]})}),"\n",(0,s.jsx)(n.h4,{id:"custom-pivot-models-and-incrementing-ids",children:"Custom Pivot Models And Incrementing IDs"}),"\n",(0,s.jsxs)(n.p,{children:["If you have defined a many-to-many relationship that uses a custom pivot model, and that pivot model has an auto-incrementing primary key, you should ensure your custom pivot model class defines an ",(0,s.jsx)(n.code,{children:"u_incrementing"})," data member that is set to ",(0,s.jsx)(n.code,{children:"true"}),"."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:"/*! Indicates if the IDs are auto-incrementing. */\nbool u_incrementing = true;\n"})}),"\n",(0,s.jsx)(n.h4,{id:"closer-look-at-defining-custom-intermediate-table-models",children:"Closer Look At Defining Custom Intermediate Table Models"}),"\n",(0,s.jsx)(n.p,{children:"I can tell that defining a custom intermediate table models is the most confusing part of the TinyORM framework, let's look closer at it."}),"\n",(0,s.jsxs)(n.p,{children:["If you are defining a custom ",(0,s.jsx)(n.code,{children:"RoleUser"})," intermediate table for the ",(0,s.jsx)(n.code,{children:"Role"})," model like in the example above then you have to pass the ",(0,s.jsx)(n.code,{children:"RoleUser"})," pivot type as the second template argument to the ",(0,s.jsx)(n.code,{children:"User::roles()"})," ",(0,s.jsx)(n.code,{children:"belongsToMany"})," relationship method and you have to pass the ",(0,s.jsx)(n.code,{children:"RoleUser"})," pivot type to the ",(0,s.jsx)(n.code,{children:"AllRelations"})," template parameter pack ",(0,s.jsxs)(n.strong,{children:["on the ",(0,s.jsx)(n.code,{children:"Role"})," model!"]})]}),"\n",(0,s.jsxs)(n.p,{children:["Do you see the confusing part? In short, if defining the ",(0,s.jsx)(n.code,{children:"User::roles()"})," relation with the custom ",(0,s.jsx)(n.code,{children:"UserRole"})," pivot model then add the ",(0,s.jsx)(n.code,{children:"UserRole"})," type to the ",(0,s.jsx)(n.code,{children:"AllRelations"})," template parameter pack on the ",(0,s.jsx)(n.code,{children:"Role"})," model."]}),"\n",(0,s.jsxs)(n.p,{children:["The same is true for the basic ",(0,s.jsx)(n.code,{children:"Pivot"})," model, if you are using a basic pivot model and not a custom pivot model you still need to add the ",(0,s.jsx)(n.code,{children:"Pivot"})," type to the ",(0,s.jsx)(n.code,{children:"AllRelations"})," template parameter pack on the ",(0,s.jsx)(n.code,{children:"Model"})," class!"]}),"\n",(0,s.jsxs)(n.p,{children:["The reason for all of this is that the ",(0,s.jsx)(n.code,{children:"Model"})," knows how to generate and work with the ",(0,s.jsx)(n.code,{children:"std::variant"})," that holds the pivot model in the ",(0,s.jsx)(n.code,{children:"Model::m_relations"})," data member map, then you can get the pivot model using the ",(0,s.jsx)(n.code,{children:"Model::getRelationValue"})," or ",(0,s.jsx)(n.code,{children:"Model::getRelation"})," methods."]}),"\n",(0,s.jsx)(n.h5,{id:"user-data-members-on-custom-intermediate-table-models",children:"User Data Members on Custom Intermediate Table Models"}),"\n",(0,s.jsxs)(n.p,{children:["This is another nonstandard part of the custom pivot models. The ",(0,s.jsx)(n.code,{children:"u_connection"})," and ",(0,s.jsx)(n.code,{children:"u_timestamps"})," user data members and the ",(0,s.jsx)(n.code,{children:"CREATED_AT()"})," and ",(0,s.jsx)(n.code,{children:"UPDATED_AT()"})," static getter methods are ignored when obtaining pivot records from the database during the lazy or eager loading."]}),"\n",(0,s.jsx)(n.p,{children:"Let's describe how these data members are resolved:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"u_connection"})," - inferred from the parent model"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"u_timestamps"})," - true if obtained pivot attributes contain both the ",(0,s.jsx)(n.code,{children:"CREATED_AT"})," and ",(0,s.jsx)(n.code,{children:"UPDATED_AT"})," attributes"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"CREATED_AT"}),", ",(0,s.jsx)(n.code,{children:"UPDATED_AT"})," - inferred from the parent model, can be overridden using the ",(0,s.jsx)(n.code,{children:"withTimestamps()"})," method"]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["All these data members are taken into account normally when you call the ",(0,s.jsx)(n.code,{children:"create"}),", ",(0,s.jsx)(n.code,{children:"save"}),", ",(0,s.jsx)(n.code,{children:"update"}),", ... on the Custom Pivot models!"]}),"\n",(0,s.jsx)(n.h2,{id:"querying-relations",children:"Querying Relations"}),"\n",(0,s.jsxs)(n.p,{children:["Since all TinyORM relationships are defined via methods, you may call those methods to obtain an instance of the relationship without actually executing a query to load the related models. In addition, all types of TinyORM relationships also serve as ",(0,s.jsx)(n.a,{href:"/database/query-builder",children:"query builders"}),", allowing you to continue to chain constraints onto the relationship query before finally executing the SQL query against your database."]}),"\n",(0,s.jsxs)(n.p,{children:["For example, imagine a blog application in which a ",(0,s.jsx)(n.code,{children:"User"})," model has many associated ",(0,s.jsx)(n.code,{children:"Post"})," models:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:'#include "models/post.hpp"\n\nusing Orm::Tiny::Model;\n\nclass User final : public Model<User, Post>\n{\n    friend Model;\n    using Model::Model;\n\npublic:\n    /*! Get all of the posts for the user. */\n    std::unique_ptr<HasMany<User, Post>>\n    posts()\n    {\n        return hasMany<Post>();\n    }\n\nprivate:\n    /*! Map of relation names to methods. */\n    QHash<QString, RelationVisitor> u_relations {\n        {"posts", [](auto &v) { v(&User::posts); }},\n    };\n};\n'})}),"\n",(0,s.jsxs)(n.p,{children:["You may query the ",(0,s.jsx)(n.code,{children:"posts"})," relationship and add additional constraints to the relationship like so:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:'#include "models/user.hpp"\n\nauto user = User::find(1);\n\nuser->posts()->whereEq("active", 1).get();\n'})}),"\n",(0,s.jsxs)(n.p,{children:["You are able to use any of the TinyORM ",(0,s.jsx)(n.a,{href:"/database/query-builder",children:"query builder's"})," methods on the relationship, so be sure to explore the query builder documentation to learn about all of the methods that are available to you."]}),"\n",(0,s.jsx)(n.admonition,{type:"note",children:(0,s.jsxs)(n.p,{children:["All the ",(0,s.jsx)(n.code,{children:"TinyBuilder"})," methods which are related to building queries are proxied on the ",(0,s.jsx)(n.code,{children:"Relation"})," base class."]})}),"\n",(0,s.jsxs)(n.h4,{id:"chaining-orwhere-clauses-after-relationships",children:["Chaining ",(0,s.jsx)(n.code,{children:"orWhere"})," Clauses After Relationships"]}),"\n",(0,s.jsxs)(n.p,{children:["As demonstrated in the example above, you are free to add additional constraints to relationships when querying them. However, be careful when chaining ",(0,s.jsx)(n.code,{children:"orWhere"})," clauses onto a relationship, as the ",(0,s.jsx)(n.code,{children:"orWhere"})," clauses will be logically grouped at the same level as the relationship constraint:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:'user->posts()\n    ->whereEq("active", 1)\n    .orWhere("votes", ">=", 100)\n    .get();\n'})}),"\n",(0,s.jsxs)(n.p,{children:["The example above will generate the following SQL. As you can see, the ",(0,s.jsx)(n.code,{children:"or"})," clause instructs the query to return ",(0,s.jsx)(n.em,{children:"any"})," user with greater than 100 votes. The query is no longer constrained to a specific user:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-sql",children:"select *\nfrom posts\nwhere user_id = ? and active = 1 or votes >= 100\n"})}),"\n",(0,s.jsxs)(n.p,{children:["In most situations, you should use ",(0,s.jsx)(n.a,{href:"/database/query-builder#logical-grouping",children:"logical groups"})," to group the conditional checks between parentheses:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:'user->posts()\n    ->where([](auto &query)\n    {\n        query.whereEq("active", 1)\n             .orWhere("votes", ">=", 100);\n    })\n    .get();\n'})}),"\n",(0,s.jsx)(n.p,{children:"The example above will produce the following SQL. Note that the logical grouping has properly grouped the constraints and the query remains constrained to a specific user:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-sql",children:"select *\nfrom posts\nwhere user_id = ? and (active = 1 or votes >= 100)\n"})}),"\n",(0,s.jsx)(n.h3,{id:"relationship-methods",children:"Relationship Methods"}),"\n",(0,s.jsxs)(n.p,{children:["If you do not need to add additional constraints to the TinyORM relationship query, you may access the relationship directly. For example, continuing to use our ",(0,s.jsx)(n.code,{children:"User"})," and ",(0,s.jsx)(n.code,{children:"Post"})," example models, we may access all of a user's posts like so:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:'#include "models/user.hpp"\n\nauto user = User::find(1);\n\nfor (auto *post : user->getRelationValue<Post>("posts")) {\n    //\n}\n'})}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.code,{children:"getRelationValue<Related>"}),' method performs "lazy loading", meaning they will only load their relationship data when you actually access them. Because of this, developers often use ',(0,s.jsx)(n.a,{href:"#eager-loading",children:"eager loading"})," to pre-load relationships they know will be accessed after loading the model. Eager loading provides a significant reduction in SQL queries that must be executed to load a model's relations."]}),"\n",(0,s.jsxs)(n.p,{children:["To access eager loaded relationship use Model's ",(0,s.jsx)(n.code,{children:"getRelation<Related>"})," method:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:'auto user = User::find(1);\n\nfor (auto *post : user->getRelation<Post>("posts")) {\n    //\n}\n'})}),"\n",(0,s.jsxs)(n.p,{children:["As described above TinyORM offers two methods to access relationships; ",(0,s.jsx)(n.code,{children:"getRelation"})," and ",(0,s.jsx)(n.code,{children:"getRelationValue"}),"."]}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.code,{children:"getRelation"}),' method is for "eager loaded" relations, when the relationship is not loaded, it throws the exception ',(0,s.jsx)(n.code,{children:"RelationNotLoadedError"}),". The ",(0,s.jsx)(n.code,{children:"getRelationValue"}),' is for "lazy loading", when the relationship is not loaded, it will load it.']}),"\n",(0,s.jsxs)(n.p,{children:["Both methods have two overloads, the ",(0,s.jsx)(n.code,{children:"getRelation<Related, Container = QVector>"})," overload is for obtaining many type relationships:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:'auto posts = User::find(1)->getRelation<Post>("posts");\n'})}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.code,{children:"getRelation<Related, Tag>"}),' overload is for obtaining "one" type relationships:']}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:'auto user = Post::find(1)->getRelation<User, Orm::One>("user");\n'})}),"\n",(0,s.jsxs)(n.p,{children:["The same is true for the ",(0,s.jsx)(n.code,{children:"getRelationValue"})," method."]}),"\n",(0,s.jsx)(n.h3,{id:"querying-relationship-existence",children:"Querying Relationship Existence"}),"\n",(0,s.jsxs)(n.p,{children:["When retrieving model records, you may wish to limit your results based on the existence of a relationship. For example, imagine you want to retrieve all blog posts that have at least one comment. To do so, you may pass the name of the relationship to the ",(0,s.jsx)(n.code,{children:"has"})," and ",(0,s.jsx)(n.code,{children:"orHas"})," methods:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:'#include "models/post.hpp"\n\n// Retrieve all posts that have at least one comment...\nauto posts = Post::has("comments")->get();\n'})}),"\n",(0,s.jsx)(n.p,{children:"You may also specify an operator and count value to further customize the query:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:'// Retrieve all posts that have three or more comments...\nauto posts = Post::has("comments", ">=", 3)->get();\n'})}),"\n",(0,s.jsxs)(n.p,{children:["Nested ",(0,s.jsx)(n.code,{children:"has"}),' statements may be constructed using "dot" notation. For example, you may retrieve all posts that have at least one comment that has at least one image:']}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:'// Retrieve posts that have at least one comment with images...\nauto posts = Post::has<Image>("comments.images")->get();\n'})}),"\n",(0,s.jsxs)(n.p,{children:["If you need even more power, you may use the ",(0,s.jsx)(n.code,{children:"whereHas"})," and ",(0,s.jsx)(n.code,{children:"orWhereHas"})," methods to define additional query constraints on your ",(0,s.jsx)(n.code,{children:"has"})," queries, such as inspecting the content of a comment:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:'// Retrieve posts with at least one comment containing words like code%...\nauto posts = Post::whereHas("comments", [](auto &query)\n{\n    query.where("content", LIKE, "code%");\n})->get();\n\n// Retrieve posts with at least ten comments containing words like code%...\nauto posts = Post::whereHas("comments", [](auto &query)\n{\n    query.where("content", LIKE, "code%");\n}, ">=", 10)->get();\n'})}),"\n",(0,s.jsx)(n.admonition,{type:"note",children:(0,s.jsx)(n.p,{children:"TinyORM does not currently support querying for relationship existence across databases. The relationships must exist within the same database."})}),"\n",(0,s.jsx)(n.h4,{id:"related-template-parameter",children:"Related template parameter"}),"\n",(0,s.jsxs)(n.p,{children:["All the ",(0,s.jsx)(n.code,{children:"has"}),"-related methods are templated by the ",(0,s.jsx)(n.code,{children:"Related"})," template parameter, it looks something like the following ",(0,s.jsx)(n.code,{children:"has<Related>(..., const std::function<void(CallbackType<Related> &)> &callback = nullptr)"}),", you can pass a query callback to this methods and on the base of the ",(0,s.jsx)(n.code,{children:"Related"})," template argument will be decided whether the ",(0,s.jsx)(n.code,{children:"Orm::QueryBuilder"})," or ",(0,s.jsx)(n.code,{children:"Orm::TinyBuilder<Related>"})," will be passed to the callback. As you can see this ",(0,s.jsx)(n.code,{children:"Related"})," parameter exists because the ",(0,s.jsx)(n.code,{children:"Orm::TinyBuilder<Related>"})," needs it."]}),"\n",(0,s.jsx)(n.p,{children:"The rule of thumbs are:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["if you don't pass the ",(0,s.jsx)(n.code,{children:"Related"})," template parameter  or you pass ",(0,s.jsx)(n.code,{children:"void"})," then the ",(0,s.jsx)(n.code,{children:"Orm::QueryBuilder &"})," will be passed to the callback"]}),"\n",(0,s.jsxs)(n.li,{children:["if you pass it, then the ",(0,s.jsx)(n.code,{children:"Orm::TinyBuilder<Related> &"})," will be passed to the callback"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"Related"})," has to be of the same type as a relation name passed to the ",(0,s.jsx)(n.code,{children:"has"}),"-related method (a real type of the relation eg. type of the ",(0,s.jsx)(n.code,{children:"posts"})," relation name is ",(0,s.jsx)(n.code,{children:"Post"}),")"]}),"\n",(0,s.jsxs)(n.li,{children:["you have to always pass the ",(0,s.jsx)(n.code,{children:"Related"})," template parameter for nested relations, you can not use nested relations with ",(0,s.jsx)(n.code,{children:"Related = void"})]}),"\n",(0,s.jsxs)(n.li,{children:['in nested relations, where you can pass more relation names using "dot" notation, ',(0,s.jsx)(n.code,{children:"Related"})," has to be of the same type as the ",(0,s.jsx)(n.strong,{children:"last"})," relation name passed to the ",(0,s.jsx)(n.code,{children:"has"}),"-related method like you can see in the nested example above or below"]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"querying-relationship-absence",children:"Querying Relationship Absence"}),"\n",(0,s.jsxs)(n.p,{children:["When retrieving model records, you may wish to limit your results based on the absence of a relationship. For example, imagine you want to retrieve all blog posts that ",(0,s.jsx)(n.strong,{children:"don't"})," have any comments. To do so, you may pass the name of the relationship to the ",(0,s.jsx)(n.code,{children:"doesntHave"})," and ",(0,s.jsx)(n.code,{children:"orDoesntHave"})," methods:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:'#include "models/post.hpp"\n\nauto posts = Post::doesntHave("comments")->get();\n'})}),"\n",(0,s.jsxs)(n.p,{children:["If you need even more power, you may use the ",(0,s.jsx)(n.code,{children:"whereDoesntHave"})," and ",(0,s.jsx)(n.code,{children:"orWhereDoesntHave"})," methods to add additional query constraints to your ",(0,s.jsx)(n.code,{children:"doesntHave"})," queries, such as inspecting the content of a comment:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:'auto posts = Post::whereDoesntHave("comments", [](auto &query)\n{\n    query.where("content", LIKE, "code%");\n})->get();\n'})}),"\n",(0,s.jsx)(n.p,{children:'You may use "dot" notation to execute a query against a nested relationship. For example, the following query will retrieve all posts that have comments from authors that are not banned:'}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:'auto posts = Post::whereDoesntHave<Author>("comments.author",\n                                           [](auto &query)\n{\n    query.where("banned", false);\n})->get();\n'})}),"\n",(0,s.jsx)(n.h2,{id:"eager-loading",children:"Eager Loading"}),"\n",(0,s.jsxs)(n.p,{children:["When accessing TinyORM relationships by Model's ",(0,s.jsx)(n.code,{children:"getRelationValue"}),' method, the related models are "lazy loaded". This means the relationship data is not actually loaded until you first access them. However, TinyORM can "eager load" relationships at the time you query the parent model. Eager loading alleviates the "N + 1" query problem. To illustrate the N + 1 query problem, consider a ',(0,s.jsx)(n.code,{children:"Book"}),' model that "belongs to" to an ',(0,s.jsx)(n.code,{children:"Author"})," model:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:'using Orm::Tiny::Model;\n\nclass Book final : public Model<Book, Author>\n{\n    friend Model;\n    using Model::Model;\n\npublic:\n    /*! Get the author that wrote the book. */\n    std::unique_ptr<BelongsTo<Book, Author>>\n    author()\n    {\n        return belongsTo<Author>();\n    }\n\nprivate:\n    /*! Map of relation names to methods. */\n    QHash<QString, RelationVisitor> u_relations {\n        {"author", [](auto &v) { v(&Book::author); }},\n    };\n};\n'})}),"\n",(0,s.jsx)(n.p,{children:"Now, let's retrieve all books and their authors:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:'#include <QDebug>\n\n#include "models/book.hpp"\n\nauto books = Book::all();\n\nfor (auto &book : books)\n    qDebug() << book.getRelationValue<Author, Orm::One>("author")\n                ->getAttribute<QString>("name");\n'})}),"\n",(0,s.jsx)(n.p,{children:"This loop will execute one query to retrieve all of the books within the database table, then another query for each book in order to retrieve the book's author. So, if we have 25 books, the code above would run 26 queries: one for the original book, and 25 additional queries to retrieve the author of each book."}),"\n",(0,s.jsxs)(n.p,{children:["Thankfully, we can use eager loading to reduce this operation to just two queries. When building a query, you may specify which relationships should be eager loaded using the ",(0,s.jsx)(n.code,{children:"with"})," method:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:'auto books = Book::with("author")->get();\n\nfor (auto &book : books)\n    qDebug() << book.getRelation<Author, Orm::One>("author")\n                ->getAttribute<QString>("name");\n'})}),"\n",(0,s.jsx)(n.p,{children:"For this operation, only two queries will be executed - one query to retrieve all of the books and one query to retrieve all of the authors for all of the books:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-sql",children:"select * from books\n\nselect * from authors where id in (1, 2, 3, 4, 5, ...)\n"})}),"\n",(0,s.jsx)(n.h4,{id:"eager-loading-multiple-relationships",children:"Eager Loading Multiple Relationships"}),"\n",(0,s.jsxs)(n.p,{children:["Sometimes you may need to eager load several different relationships. To do so, just pass a ",(0,s.jsx)(n.code,{children:"QVector<Orm::WithItem>"})," of relationships to the ",(0,s.jsx)(n.code,{children:"with"})," method:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:'auto books = Book::with({"author", "publisher"})->get();\n'})}),"\n",(0,s.jsx)(n.h4,{id:"nested-eager-loading",children:"Nested Eager Loading"}),"\n",(0,s.jsx)(n.p,{children:"To eager a relationship's relationships, you may use \"dot\" syntax. For example, let's eager load all of the book's authors and all of the author's personal contacts:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:'auto books = Book::with("author.contacts")->get();\n'})}),"\n",(0,s.jsx)(n.h4,{id:"eager-loading-specific-columns",children:"Eager Loading Specific Columns"}),"\n",(0,s.jsx)(n.p,{children:"You may not always need every column from the relationships you are retrieving. For this reason, TinyORM allows you to specify which columns of the relationship you would like to retrieve:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:'auto books = Book::with("author:id,name,book_id")->get();\n'})}),"\n",(0,s.jsx)(n.admonition,{type:"warning",children:(0,s.jsxs)(n.p,{children:["When using this feature, you should always include the ",(0,s.jsx)(n.code,{children:"id"})," column and any relevant foreign key columns in the list of columns you wish to retrieve, otherwise relations will not be loaded correctly."]})}),"\n",(0,s.jsx)(n.h4,{id:"eager-loading-by-default",children:"Eager Loading By Default"}),"\n",(0,s.jsxs)(n.p,{children:["Sometimes you might want to always load some relationships when retrieving a model. To accomplish this, you may define a ",(0,s.jsx)(n.code,{children:"u_with"})," data member on the model:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:'using Orm::Tiny::Model;\n\nclass Book final : public Model<Book, Author>\n{\n    friend Model;\n    using Model::Model;\n\npublic:\n    /*! Get the author that wrote the book. */\n    std::unique_ptr<BelongsTo<Book, Author>>\n    author()\n    {\n        return belongsTo<Author>();\n    }\n\nprivate:\n    /*! Map of relation names to methods. */\n    QHash<QString, RelationVisitor> u_relations {\n        {"author", [](auto &v) { v(&Book::author); }},\n    };\n\n    /*! The relationships that should always be loaded. */\n    QVector<QString> u_with {\n        "author",\n    };\n};\n'})}),"\n",(0,s.jsxs)(n.p,{children:["If you would like to remove an item from the ",(0,s.jsx)(n.code,{children:"u_with"})," data member for a single query, you may use the ",(0,s.jsx)(n.code,{children:"without"})," method:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:'auto books = Book::without("author")->get();\n'})}),"\n",(0,s.jsxs)(n.p,{children:["If you would like to override all items within the ",(0,s.jsx)(n.code,{children:"u_with"})," data member for a single query, you may use the ",(0,s.jsx)(n.code,{children:"withOnly"})," method:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:'auto books = Book::withOnly("genre")->get();\n'})}),"\n",(0,s.jsx)(n.h3,{id:"constraining-eager-loads",children:"Constraining Eager Loads"}),"\n",(0,s.jsxs)(n.p,{children:["Sometimes you may wish to eager load a relationship but also specify additional query conditions for the eager loading query. You can accomplish this by passing a ",(0,s.jsx)(n.code,{children:"QVector<Orm::WithItem>"})," of relationships to the ",(0,s.jsx)(n.code,{children:"with"})," method where the ",(0,s.jsx)(n.code,{children:"name"})," data member of ",(0,s.jsx)(n.code,{children:"Orm::WithItem"})," struct is a relationship name and the ",(0,s.jsx)(n.code,{children:"constraints"})," data member expects a lambda expression that adds additional constraints to the eager loading query. The first argument passed to the ",(0,s.jsx)(n.code,{children:"constraints"})," lambda expression is an underlying ",(0,s.jsx)(n.code,{children:"Orm::QueryBuilder"})," for a related model:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:'#include "models/user.hpp"\n\nauto users = User::with({{"posts", [](auto &query)\n{\n    query.where("title", "like", "%code%");\n}}})->get();\n'})}),"\n",(0,s.jsxs)(n.p,{children:["In this example, TinyORM will only eager load posts where the post's ",(0,s.jsx)(n.code,{children:"title"})," column contains the word ",(0,s.jsx)(n.code,{children:"code"}),". You may call other ",(0,s.jsx)(n.a,{href:"/database/query-builder",children:"query builder"})," methods to further customize the eager loading operation:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:'auto users = User::with({{"posts", [](auto &query)\n{\n    query.orderBy("created_at", "desc");\n}}})->get();\n'})}),"\n",(0,s.jsx)(n.admonition,{type:"note",children:(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.code,{children:"limit"})," and ",(0,s.jsx)(n.code,{children:"take"})," query builder methods may not be used when constraining eager loads."]})}),"\n",(0,s.jsx)(n.h3,{id:"lazy-eager-loading",children:"Lazy Eager Loading"}),"\n",(0,s.jsx)(n.p,{children:"Sometimes you may need to eager load a relationship after the parent model has already been retrieved. For example, this may be useful if you need to dynamically decide whether to load related models:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:'#include "models/book.hpp"\n\nauto book = Book::find(1);\n\nif (someCondition)\n    book->load("author");\n'})}),"\n",(0,s.jsxs)(n.p,{children:["You may load more relationships at once, to do so, just pass a ",(0,s.jsx)(n.code,{children:"QVector<Orm::WithItem>"})," of relationships to the ",(0,s.jsx)(n.code,{children:"load"})," method:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:'Book::find(1)->load({"author", "publisher"});\n'})}),"\n",(0,s.jsx)(n.admonition,{type:"note",children:(0,s.jsxs)(n.p,{children:["So far, this only works on models, not on containers returned from Model's ",(0,s.jsx)(n.code,{children:"get"})," or ",(0,s.jsx)(n.code,{children:"all"})," methods."]})}),"\n",(0,s.jsxs)(n.p,{children:["If you need to set additional query constraints on the eager loading query, you may pass a ",(0,s.jsx)(n.code,{children:"QVector<Orm::WithItem>"})," of relationships to the ",(0,s.jsx)(n.code,{children:"load"})," method where the ",(0,s.jsx)(n.code,{children:"name"})," data member of ",(0,s.jsx)(n.code,{children:"Orm::WithItem"})," struct is a relationship name and the ",(0,s.jsx)(n.code,{children:"constraints"})," data member expects a lambda expression that adds additional constraints to the eager loading query. The first argument passed to the ",(0,s.jsx)(n.code,{children:"constraints"})," lambda expression is an underlying ",(0,s.jsx)(n.code,{children:"Orm::QueryBuilder"})," for a related model:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:'author->load({{"books", [](auto &query)\n{\n    query.orderBy("published_date", "asc");\n}}});\n'})}),"\n",(0,s.jsx)(n.admonition,{type:"tip",children:(0,s.jsxs)(n.p,{children:["You can also use eager constraining in the Model's ",(0,s.jsx)(n.code,{children:"fresh"})," method."]})}),"\n",(0,s.jsx)(n.h2,{id:"inserting-and-updating-related-models",children:"Inserting & Updating Related Models"}),"\n",(0,s.jsxs)(n.h3,{id:"the-save-method",children:["The ",(0,s.jsx)(n.code,{children:"save"})," Method"]}),"\n",(0,s.jsxs)(n.p,{children:["TinyORM provides convenient methods for adding new models to relationships. For example, perhaps you need to add a new comment to a post. Instead of manually setting the ",(0,s.jsx)(n.code,{children:"post_id"})," attribute on the ",(0,s.jsx)(n.code,{children:"Comment"})," model you may insert the comment using the relationship's ",(0,s.jsx)(n.code,{children:"save"})," method:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:'#include "models/comment.hpp"\n#include "models/post.hpp"\n\nComment comment({{"message", "A new comment."}});\n\nauto post = Post::find(1);\n\npost->comments()->save(comment);\n'})}),"\n",(0,s.jsxs)(n.p,{children:["Note that we did not access the ",(0,s.jsx)(n.code,{children:"comments"})," relationship with the ",(0,s.jsx)(n.code,{children:"getRelation"})," or ",(0,s.jsx)(n.code,{children:"getRelationValue"})," method. Instead, we called the ",(0,s.jsx)(n.code,{children:"comments"})," method to obtain an instance of the relationship. The ",(0,s.jsx)(n.code,{children:"save"})," method will automatically add the appropriate ",(0,s.jsx)(n.code,{children:"post_id"})," value to the new ",(0,s.jsx)(n.code,{children:"Comment"})," model."]}),"\n",(0,s.jsxs)(n.p,{children:["If you need to save multiple related models, you may use the ",(0,s.jsx)(n.code,{children:"saveMany"})," method:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:'auto post = Post::find(1);\n\npost->comments()->saveMany({\n    {{"message", "A new comment."}},\n    {{"message", "Another new comment."}},\n});\n'})}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.code,{children:"save"})," and ",(0,s.jsx)(n.code,{children:"saveMany"})," methods will not add the new models to any in-memory relationships that are already loaded onto the parent model. If you plan on accessing the relationship after using the ",(0,s.jsx)(n.code,{children:"save"})," or ",(0,s.jsx)(n.code,{children:"saveMany"})," methods, you may wish to use the ",(0,s.jsx)(n.code,{children:"refresh"})," method to reload the model and its relationships:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:'post->comments()->save(comment);\n\npost->refresh();\n\n// All comments, including the newly saved comment...\npost->getRelation<Comment>("comments");\n'})}),"\n",(0,s.jsxs)(n.p,{children:["The many-to-many relationship also supports the ",(0,s.jsx)(n.code,{children:"save"})," and ",(0,s.jsx)(n.code,{children:"saveMany"})," methods. In addition, you may pass the pivot attributes as a second argument and select if you want to touch parent timestamps as a third argument:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:'auto user = User::find(2);\n\nRole role {{"name", "admin"}};\n\nuser->roles()->save(role, {{"active", true}});\n\nRole role1 {{"name", "edit"}};\nRole role2 {{"name", "view"}};\n\nuser->roles()->saveMany({role1, role2}, {{{"active", true}},\n                                         {{"active", false}}});\n\n// No pivot attributes for role1\nuser->roles()->saveMany({role1, role2}, {{}, {{"active", false}}});\n'})}),"\n",(0,s.jsx)(n.h4,{id:"recursively-saving-models--relationships",children:"Recursively Saving Models & Relationships"}),"\n",(0,s.jsxs)(n.p,{children:["If you would like to ",(0,s.jsx)(n.code,{children:"save"})," your model and all of its associated relationships, you may use the ",(0,s.jsx)(n.code,{children:"push"})," method. In this example, the ",(0,s.jsx)(n.code,{children:"Post"})," model will be saved as well as its comments and the comment's authors:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:'auto post = Post::find(1);\n\npost->getRelationValue<Comment>("comments").at(0)->setAttribute("message", "Message");\n\npost->getRelationValue<Comment>("comments").first()\n    ->getRelationValue<User, Orm::One>("author")->setAttribute("name", "Author Name");\n\npost->push();\n'})}),"\n",(0,s.jsxs)(n.h3,{id:"the-create-method",children:["The ",(0,s.jsx)(n.code,{children:"create"})," Method"]}),"\n",(0,s.jsxs)(n.p,{children:["In addition to the ",(0,s.jsx)(n.code,{children:"save"})," and ",(0,s.jsx)(n.code,{children:"saveMany"})," methods, you may also use the ",(0,s.jsx)(n.code,{children:"create"})," method, which accepts a vector of attributes, creates a model, and inserts it into the database. The difference between ",(0,s.jsx)(n.code,{children:"save"})," and ",(0,s.jsx)(n.code,{children:"create"})," is that ",(0,s.jsx)(n.code,{children:"save"})," accepts a full TinyORM model instance while ",(0,s.jsx)(n.code,{children:"create"})," accepts a ",(0,s.jsx)(n.code,{children:"QVector<Orm::AttributeItem>"}),". The newly created model will be returned by the ",(0,s.jsx)(n.code,{children:"create"})," method:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:'#include "models/post.hpp"\n\nauto post = Post::find(1);\n\nauto comment = post->comments()->create({\n    {"message", "A new comment."},\n});\n'})}),"\n",(0,s.jsxs)(n.p,{children:["You may use the ",(0,s.jsx)(n.code,{children:"createMany"})," method to create multiple related models:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:'auto post = Post::find(1);\n\nauto comments = post->comments()->createMany({\n    {{"message", "A new comment."}, {"is_published", true}},\n    {{"message", "Another new comment."}, {"is_published", false}},\n});\n'})}),"\n",(0,s.jsxs)(n.p,{children:["The many-to-many relationship also supports the ",(0,s.jsx)(n.code,{children:"create"})," and ",(0,s.jsx)(n.code,{children:"createMany"})," methods. In addition, you may pass the pivot attributes as a second argument and select if you want to touch parent timestamps as a third argument:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:'auto user = User::find(2);\n\nuser->roles()->create({{"name", "admin"}}, {{"active", true}});\n\nuser->roles()->createMany({\n    {{"name", "edit"}},\n    {{"name", "view"}},\n}, {\n    {{"active", true}},\n    {{"active", false}},\n});\n\n// No pivot attributes for the first role\nuser->roles()->createMany({\n    {{"name", "edit"}},\n    {{"name", "view"}},\n}, {\n    {},\n    {{"active", false}},\n});\n'})}),"\n",(0,s.jsxs)(n.p,{children:["You may also use the ",(0,s.jsx)(n.code,{children:"findOrNew"}),", ",(0,s.jsx)(n.code,{children:"firstOrNew"}),", ",(0,s.jsx)(n.code,{children:"firstOrCreate"}),", and ",(0,s.jsx)(n.code,{children:"updateOrCreate"})," methods to ",(0,s.jsx)(n.a,{href:"/tinyorm/getting-started#retrieving-or-creating-models",children:"create and update models on relationships"}),"."]}),"\n",(0,s.jsx)(n.admonition,{type:"tip",children:(0,s.jsxs)(n.p,{children:["Before using the ",(0,s.jsx)(n.code,{children:"create"})," method, be sure to review the ",(0,s.jsx)(n.a,{href:"/tinyorm/getting-started#mass-assignment",children:"mass assignment"})," documentation."]})}),"\n",(0,s.jsx)(n.h3,{id:"updating-belongs-to-relationships",children:"Belongs To Relationships"}),"\n",(0,s.jsxs)(n.p,{children:["If you would like to assign a child model to a new parent model, you may use the ",(0,s.jsx)(n.code,{children:"associate"})," method. In this example, the ",(0,s.jsx)(n.code,{children:"User"})," model defines a ",(0,s.jsx)(n.code,{children:"belongsTo"})," relationship to the ",(0,s.jsx)(n.code,{children:"Account"})," model. The ",(0,s.jsx)(n.code,{children:"associate"})," method will set the foreign key on the child model:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:'#include "models/user.hpp"\n\nUser user {{"name", "Mike"}};\n\nauto account = Account::find(10);\n\nuser.account()->associate(*account);\n\nuser.save();\n'})}),"\n",(0,s.jsxs)(n.p,{children:["To remove a parent model from a child model, you may use the ",(0,s.jsx)(n.code,{children:"dissociate"})," method. This method will set the relationship's foreign key to ",(0,s.jsx)(n.code,{children:"null"}),":"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:"user.account()->dissociate();\n\nuser.save();\n"})}),"\n",(0,s.jsx)(n.h3,{id:"updating-many-to-many-relationships",children:"Many To Many Relationships"}),"\n",(0,s.jsx)(n.h4,{id:"attaching--detaching",children:"Attaching / Detaching"}),"\n",(0,s.jsxs)(n.p,{children:["TinyORM also provides methods to make working with many-to-many relationships more convenient. For example, let's imagine a user can have many roles and a role can have many users. You may use the ",(0,s.jsx)(n.code,{children:"attach"})," method to attach a role to a user by inserting a record in the relationship's intermediate table:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:'#include "models/user.hpp"\n\nauto user = User::find(1);\n\nuser->roles()->attach(roleId);\n'})}),"\n",(0,s.jsx)(n.p,{children:"When attaching a relationship to a model, you may also pass a vector of additional data to be inserted into the intermediate table:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:'const auto expires = true;\n\nuser->roles()->attach(roleId, {{"expires", expires}});\n'})}),"\n",(0,s.jsxs)(n.p,{children:["Sometimes it may be necessary to remove a role from a user. To remove a many-to-many relationship record, use the ",(0,s.jsx)(n.code,{children:"detach"})," method. The ",(0,s.jsx)(n.code,{children:"detach"})," method will delete the appropriate record out of the intermediate table; however, both models will remain in the database:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:"// Detach a single role from the user...\nuser->roles()->detach(roleId);\n\n// Detach all roles from the user...\nuser->roles()->detachAll();\n"})}),"\n",(0,s.jsxs)(n.p,{children:["For convenience, ",(0,s.jsx)(n.code,{children:"attach"})," and ",(0,s.jsx)(n.code,{children:"detach"})," also accept vectors of IDs or Model instances as input:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:'auto user = User::find(1);\n\nuser->roles()->detach({1, 2, 3});\n\nRole role1({{"name", "Role 1"}});\nrole1.save();\nRole role2({{"name", "Role 2"}});\nrole2.save();\n\nuser->roles()->attach({{role1}, {role2}});\n'})}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.code,{children:"attach"})," method also accepts ",(0,s.jsx)(n.code,{children:"std::map"})," as input, so you can pass different attributes for each model you are attaching:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:'user->roles()->attach({\n    {1, {{"expires", true},  {"is_active", false}}},\n    {2, {{"expires", false}, {"is_active", true}}},\n});\n'})}),"\n",(0,s.jsx)(n.h4,{id:"syncing-associations",children:"Syncing Associations"}),"\n",(0,s.jsxs)(n.p,{children:["You may also use the ",(0,s.jsx)(n.code,{children:"sync"})," method to construct many-to-many associations. The ",(0,s.jsx)(n.code,{children:"sync"})," method accepts a vector of IDs to place on the intermediate table. Any IDs that are not in the given vector will be removed from the intermediate table. So, after this operation is complete, only the IDs in the given vector will exist in the intermediate table:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:"user->roles()->sync({1, 2, 3});\n"})}),"\n",(0,s.jsx)(n.p,{children:"You may also pass additional intermediate table values with the IDs:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:'user->roles()->sync({\n    {1, {{"expires", true}}},\n    {2, {}},\n    {3, {}},\n});\n'})}),"\n",(0,s.jsxs)(n.p,{children:["If you do not want to detach existing IDs that are missing from the given vector, you may use the ",(0,s.jsx)(n.code,{children:"syncWithoutDetaching"})," method:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:"user->roles()->syncWithoutDetaching({1, 2, 3});\n"})}),"\n",(0,s.jsx)(n.h4,{id:"updating-a-record-on-the-intermediate-table",children:"Updating A Record On The Intermediate Table"}),"\n",(0,s.jsxs)(n.p,{children:["If you need to update an existing row in your relationship's intermediate table, you may use the ",(0,s.jsx)(n.code,{children:"updateExistingPivot"})," method. This method accepts the intermediate record foreign key and the vector of attributes to update:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:'auto user = User::find(1);\n\nuser->roles()->updateExistingPivot(roleId, {\n    {"active", false},\n});\n'})}),"\n",(0,s.jsx)(n.h2,{id:"touching-parent-timestamps",children:"Touching Parent Timestamps"}),"\n",(0,s.jsxs)(n.p,{children:["When a model defines a ",(0,s.jsx)(n.code,{children:"belongsTo"})," relationship to another model, such as a ",(0,s.jsx)(n.code,{children:"Comment"})," which belongs to a ",(0,s.jsx)(n.code,{children:"Post"}),", it is sometimes helpful to update the parent's timestamp when the child model is updated."]}),"\n",(0,s.jsxs)(n.p,{children:["For example, when a ",(0,s.jsx)(n.code,{children:"Comment"}),' model is updated, you may want to automatically "touch" the ',(0,s.jsx)(n.code,{children:"updated_at"})," timestamp of the owning ",(0,s.jsx)(n.code,{children:"Post"})," so that it is set to the current date and time. To accomplish this, you may add a ",(0,s.jsx)(n.code,{children:"u_touches"})," data member to your child model containing the names of the relationships that should have their ",(0,s.jsx)(n.code,{children:"updated_at"})," timestamps updated when the child model is updated:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:'using Orm::Tiny::Model;\n\nclass Comment final : public Model<Comment, Post>\n{\n    friend Model;\n    using Model::Model;\n\npublic:\n    /*! Get the post that owns the comment. */\n    std::unique_ptr<BelongsTo<Comment, Post>>\n    post()\n    {\n        return belongsTo<Post>();\n    }\n\nprivate:\n    /*! Map of relation names to methods. */\n    QHash<QString, RelationVisitor> u_relations {\n        {"post", [](auto &v) { v(&Comment::post); }},\n    };\n\n    /*! All of the relationships to be touched. */\n    QStringList u_touches {"post"};\n};\n'})}),"\n",(0,s.jsx)(n.admonition,{type:"note",children:(0,s.jsxs)(n.p,{children:["Parent model timestamps will only be updated if the child model is updated using TinyORM's ",(0,s.jsx)(n.code,{children:"save"}),", ",(0,s.jsx)(n.code,{children:"push"}),", or ",(0,s.jsx)(n.code,{children:"remove"})," method."]})})]})}function c(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(h,{...e})}):h(e)}},8453:(e,n,o)=>{o.d(n,{R:()=>a,x:()=>r});var s=o(6540);const t={},i=s.createContext(t);function a(e){const n=s.useContext(i);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function r(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:a(e.components),s.createElement(i.Provider,{value:n},e.children)}}}]);